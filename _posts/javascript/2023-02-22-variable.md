---
title: "[Deep Dive]  3. 변수"
excerpt: "variable"

categories:
  - javascript
tags:
  - [javascript, variable]

toc: true
toc_sticky: true

date: 2023-02-22
last_modified_at: 2023-02-24
---

## 1. 변수의 정의와 사용하는 이유

### 변수의 의미

- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체
- 메모리 공간을 식별하기 위해 붙인 이름

### 변수를 사용하는 이유

기억하고 싶은 값을 메모리에 저장하고, 그 값을 다시 참조해서 재사용하기 위해 변수라는 메커니즘을 사용한다.

### 변수와 관련된 용어

- 변수 이름(변수명) <br/>
  메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
- 변수 값<br/>
  변수에 저장된 값
- 할당(대입,저장)<br/>
  변수에 값을 저장하는 것
- 참조<br/>
  변수에 저장된 값을 읽어들이는 것
- 식별자<br/>
  어떤 값을 구별해서 식별할 수 있는 고유한 이름. 값이 저장된 메모리의 **주소**를 기억해서, 그 메모리에 저장된 값에 접근할 수 있다. 변수, 함수, 클래스 등의 이름은 모두 식별자이며, 선언을 통해 식별자임을 자바스크립트 엔진에 알려준다.

## 2. 변수를 선언하는 방법

### 변수 선언

- 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것

### 변수 선언 방법

- var, let, const 키워드를 사용한다.<br/>
  (var의 단점을 보완하기 위해 let과 const 키워드가 ES6에서 추가되었다.[참고](https://sena-22.github.io/javascript/variable/#8-let-const-키워드))

```javascript
//변수 선언
let tomato; // let 키워드 + 변수 이름
```

키워드는 자바스크립트 엔진이 수행할 동작을 규정해놓은 명령어이다. 위에서는 let이 키워드이며, 뒤에 오는 변수 이름(여기서 tomato)으로 변수를 선언하라고 하는 것이다.
{: .notice--primary}

### 변수가 선언되는 단계

변수는 선언 단계와 초기화 단계를 거쳐 선언을 수행한다.

- 선언 단계 : 변수 이름을 자바스크립트 엔진에 알려준다.
- 초기화 단계 : 메모리 공간을 확보하고, undefined를 할당해서 초기화한다.
  초기화 단계를 거치지 않으면 확보한 메모리 공간에 예전 값이 남아 있을 수 있다.

## 3. 값 할당 & 재할당하기

### 변수에 값을 할당하는 방법

변수에 값을 할당할 때는 할당 연산자(=)를 사용해 오른쪽의 값을 왼쪽에 할당한다.

```javascript
let tomato;
tomato = 800;

//선언과 할당을 동시에 할 수도 있다
let tomato = 800;
```

### 변수 선언과 값의 할당 시점

- 변수 선언 : 코드가 실행되는 런타임 이전에 실행된다.
- 값의 할당 : 코드가 실행되는 시점인 런타임에 실행된다.

```javascript
// 변수 선언
let tomato;

// 선언은 되었지만 값이 할당되지 않아 undefined가 반환된다
console.log(tomato); //undefined

// 값 할당
tomato = 800;

// 변수에 값이 할당되었으므로 변수에 저장된 값이 반환된다.
console.log(tomato); //800
```

### 값을 재할당할 때 생기는 일

- 재할당은 이미 값이 할당된 변수에 새로운 값을 다시 할당하는 것이다
- 변수는 선언과 동시에 undefined로 초기화되기 때문에, 처음으로 값을 할당하는 것도 사실 재할당이라고 할 수 있다.
- const 키워드로 선언한 변수는 할당과 동시에 초기화해야 하고, 재할당이 불가능하다(그래서 보통 변수가 아니라 상수를 선언하기 위해 사용한다. [아래](https://sena-22.github.io/javascript/variable/#const-키워드)에서 더 자세히 알아볼 것이다)
- 재할당할 때, 원래 있던 메모리 공간에 새로운 값을 덮어씌우는 것이 아니고, <Mark>새로운 메모리 공간을 확보하고 그 공간에 값을 저장</Mark>하는 방식으로 동작한다. 그 전에 사용하던 메모리 공간은 변수 이름과 연결이 끊어지므로 그 안에 들어있는 값 역시 참조할 수도 없고, 필요하지 않게 된다. 이런 값들은 가비지 콜렉터에 의해 메모리에서 해제된다.

## 4. 식별자 네이밍 규칙

### 식별자 네이밍 규칙

- 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함할 수 있다.
- 숫자로 시작할 수 없다.
- 예약어는 사용할 수 없다.

예약어는 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말한다.
javascript의 예약어는 await, break, continue, function, if 등이 있다.
[javascript의 예약어](https://www.w3schools.com/js/js_reserved.asp)

🧐 키워드와 예약어의 차이? <br/>
키워드는 특정 목적을 수행하기 위해 쓰이는데, 예약어는 아직 쓰임새는 없지만 키워드로 쓸 가능성이 있어 예약해 둔 단어라고 한다. 언어마다 키워드와 예약어가 동일한 언어도 있고, 다른 언어도 있다.

### 네이밍 컨벤션

하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성을 높이기 위해 규정한 명명 규칙이다.

### 자주 사용되는 네이밍 컨벤션

```javascript
// 카멜 케이스
let firstName; //변수, 함수 이름에 자주 사용

// 스네이크 케이스
let frist_name;

// 파스칼 케이스
let FirstName; //생성자 함수, 클래스 이름에 자주 사용

// 헝가리안 케이스
let strFirstName;
let $elem;
```

## 5. 변수의 호이스팅

### 변수 호이스팅의 의미

변수 호이스팅은 **변수 선언문이 코드의 선두로 올려진 것처럼 동작하는 것**을 말한다.
위에서 변수가 선언되는 시점이 런타임 이전이라고 했는데, 변수 호이스팅 때문에 그렇게 동작하는 것이다.

```javascript
console.log(tomato); //undefined

var tomato;
```

var로 선언한 변수의 경우 선언 이전에 참조해도 에러가 나지 않는다.

### var와 let의 변수 호이스팅

- var로 선언한 변수의 경우 선언 이전에 참조해도 에러가 나지 않는다.

```javascript
console.log(tomato); //undefined

var tomato;
```

- 반면 let으로 선언한 경우 선언 이전에 참조하면 참조 에러가 나타난다.

```javascript
console.log(tomato); //Uncaught ReferenceError: tomato is not defined

let tomato;
```

let으로 선언한 변수가 호이스팅이 일어나지 않는 것은 아니다. 하지만 선언 단계와 초기화 단계가 한번에 진행되는 var 키워드와 달리, <Mark>let 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리</Mark>되어 진행된다. 선언 단계는 런타임 이전에 일어나지만, 초기화 단계는 선언문에 도달했을 때 실행된다. 따라서 선언 단계와 초기화 단계 사이에 변수를 참조할 수 없는 구간이 생기고, 이 구간을 <Mark>일시적 사각지대(Temporal Dead Zone)</Mark>라고 부른다.

## 6. 변수의 생명주기

- 변수는 생성되고 소멸되는 생명주기를 가진다.

- 변수의 생명주기는 메모리 공간이 확보된 시점 ~ 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지이다.

- 전역 변수의 생명 주기는 애플리케이션의 생명 주기와 일치하고, 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.

- 전역 변수와 지역 변수의 호이스팅은 조금 다르다. 호이스팅이 스코프 단위로 일어나기 때문이다. 전역 변수의 경우 전역 스코프의 상위로 끌어올려진 것처럼 호이스팅되지만, 지역 변수의 경우 지역 스코프의 상위로 끌어올려진 것처럼 호이스팅된다.

```javascript
var a = "global";

function con() {
  console.log(a); //지역 스코프에서 a가 선언되었지만 초기화되지 않은 상태
  var a = "local";
}

con(); //undefined
console.log(a); //'global'
```

## 7. 전역 변수의 문제점과 억제 방법

### 1. 암묵적 결합

암묵적 결합이란 모든 코드가 전역 변수를 참조하고 변경할 수 있도록 허용하는 것을 말하는데, 이는 코드의 가독성을 해치고 의도치 않은 상태 변경을 유발할 수 있다.

### 2. 긴 생명 주기

전역 변수는 생명 주기가 길기 때문에 메모리도 오래 소비하고 변수의 이름이 중복될 가능성도 높아진다.

### 3. 스코프 체인 상에서 종점에 존재

변수를 찾을 때 전역 변수는 마지막에 검색하기 때문에 속도가 가장 느리다.

### 4. 네임스페이스 오염

파일이 분리되어 있어도 스코프를 공유하기 때문에 다른 파일에서 전역으로 명명된 변수가 있을 경우 문제가 발생할 수 있다.

### 전역 변수의 사용을 억제하는 방법

- 즉시 실행 함수 : 즉시 실행 함수는 단 한 번만 호출되기 때문에 즉시 실행 함수에 감싸진 변수는 즉시 실행 함수의 지역 변수가 된다.
- 네임스페이스 객체 : 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용할 변수를 프로퍼티로 추가하는 방법이다.

```javascript
var MYAPP = {}; //전역 네임스페이스 객체

MYAPP.name = "jack";

console.log(MYAPP.name); //'jack'
```

- 이외에도 클로저를 기반으로 작동하는 모듈 패턴을 사용하거나, 전역 변수를 사용할 수 없게 만드는 ES6 모듈을 사용하는 방법도 있다.

## 8. let, const 키워드

### var 키워드로 선언한 변수의 문제점

- 변수의 중복 선언 허용
- 함수 레벨 스코프<br/>
  var 키워드로 선언한 변수는 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 if문이나 for문 안의 변수는 전역 변수가 되기 때문에 전역 변수가 남용되는 일이 일어날 수 있다.
- 변수 호이스팅<br/>
  위에서 본 것처럼 선언과 초기화가 한번에 일어나 변수 선언문 이전에 참조가 가능하다.

### let 키워드

- 변수 중복 선언 금지<br/>
  let으로 선언한 변수는 중복 선언이 불가능하다. (재할당은 가능하다)

- 블록 레벨 스코프 <br/> 함수 코드 블록만을 지역 스코프로 인정하는 var와 달리 let으로 선언한 변수는 if문이나 for문, while문 등 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.
- 변수 호이스팅 <br/>
  변수의 선언과 초기화를 분리하여 일시적 사각 지대에서 참조할 경우 에러가 발생하여 마치 호이스팅이 일어나지 않는 것처럼 동작한다.

### const 키워드

- 선언과 초기화<br/>
  const로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.

```javascript
const apple; //Uncaught SyntaxError: Missing initializer in const declaration

const apple = 800;
```

- 재할당 금지<br/>
  const로 선언한 변수는 재할당이 금지된다. 이 특징을 이용하여 const 키워드를 상수를 표현하는 데 사용하기도 한다. 고정된 값을 사용할 때 상수로 정의하여 사용하면 의미를 파악하기 쉬워진다. 일반적으로 상수를 선언할 때에는 대문자로 선언하고, 스네이크 케이스를 사용한다.

```javascript
const VAT = 0.1; // 상수로 선언. 세율이 바뀌면 이 값만 조정하면 된다.

let preTaxPrice = 100; //세전

let afterTaxPrice = preTaxPrice + preTaxPrice * VAT; // 세후

console.log(afterTaxPrice); //110
```

- const 키워드와 객체<br/>
  const 키워드로 할당된 원시 값은 변경할 수 없지만, 객체는 값을 변경할 수 있다. 새로운 값을 재할당하는 것이 아니라 프로퍼티를 생성, 삭제, 수정하는 방법을 통해 변경할 수 있기 때문이다.

```javascript
const apple = {
  price: 100,
};

apple.price = 200; //재할당 없이 변경

console.log(apple); // {price: 200}
```

변수를 선언할 때에는 기본적으로 const를 사용하고, 재할당이 필요한 경우에 한정하여 let을 사용하는 방법이 가장 안전하다고 한다.

deep dive 4장, 14장, 15장 참고
{: .notice--danger}
