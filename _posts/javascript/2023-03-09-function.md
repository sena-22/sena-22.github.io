---
title: "[Deep Dive] 10. 함수"
excerpt: "function"

categories:
  - javascript
tags:
  - [javascript, function]

toc: true
toc_sticky: true

date: 2023-03-09
last_modified_at: 2023-03-09
---

# 함수

- 동일한 작업을 반복해야 할 때 함수를 사용한다.
- 함수를 이용하면 코드를 다시 사용할 수 있기 때문에 유지보수하기도 편하고 실수를 줄일 수 있다.

# 함수 리터럴

- 함수 리터럴을 이용하여 함수를 생성할 수 있다.
- 함수 리터럴은 **function 키워드**, **함수 이름**, **매개변수**, **함수 몸체**로 구성된다.

## 함수 이름

- 함수 이름은 **식별자**이다. 따라서 식별자 네이밍 규칙을 준수해야 한다.
- 함수 이름은 생략이 가능하며, 이름이 있으면 기명 함수, 없으면 무명/익명 함수라고 부른다.

## 매개변수

- 매개변수는 0개 이상이며 소괄호로 감싸고 쉼표로 구분한다.
- 매개변수는 함수 호출할 때 지정한 인수가 순서대로 할당되기 때문에 순서가 중요하다.
- 매개변수는 함수 내에서 변수처럼 사용되기 때문에 식별자 네이밍 규칙을 준수해야 한다.

# 함수 정의

- 함수를 정의하는 방법에는 4가지가 있다.

## 함수 선언문

```javascript
function getTotal(a, b) {
  return a + b
}
```

- 함수 선언문은 이름을 생략할 수 없다.(함수 표현식은 가능)
- 표현식이 아닌 문이기 때문에 실행 시 `undefined`가 출력된다.
- 함수 선언문으로 정의한 함수는 함수 호이스팅이 발생한다. 따라서 선언문 이전에 호출이 가능하다.

## 함수 표현식

```javascript
const getTotal = function (a, b) {
  return a + b
}
```

- 함수 이름을 생략할 수 있다.
- 함수 표현식으로 정의한 함수는 변수 호이스팅이 발생한다. 따라서 선언문 이전에 참조하거나 호출할 수 없다. (참조 시 undefined로 평가되며, 호출 시 undefined를 호출하게 되므로 타입 에러가 발생한다.)

## Function 생성자 함수

```javascript
const getTotal = new Function("a", "b", "return a+b")
```

- 인수가 없는 경우엔 이렇게 만든다

```javascript
const showTime = new Function('console.log("show time!")')
```

## 화살표 함수(ES6)

```javascript
const getTotal = (a, b) => a + b
```

- 화살표 함수는 항상 익명 함수로 정의한다.

# 함수 호출

## 매개변수와 인수

함수가 호출될 때, 함수 내부에서 매개변수가 생성되고 인수가 순서대로 할당된다. 이때 매개변수의 스코프는 함수 내부이므로 함수 외부에서는 참조할 수 없다.

```javascript
const add = (a, b) => a + b

add(2, 5) // 7
console.log(a, b) //a is not defined
```

자바스크립트는 매개변수와 인수의 개수를 확인하지 않고, 타입을 사전에 지정할 수 없는 동적 타입 언어이기 때문에 문제가 발생하기도 한다.

### 매개변수와 인수의 개수가 다를 때

만약 매개변수가 인수보다 많다면, 인수를 받지 못한 매개변수는 undefined로 초기화된 상태로 작동한다.

```javascript
const add = (a, b, c) => a + b + c

add(2, 5) // NaN // c가 undefined이므로 계산이 불가능하다.
```

반대로 인수가 매개변수보다 많다면, 남는 인수는 무시된다.

```javascript
const add = (a, b) => a + b

add(2, 5, 6) // 7 // 6은 무시된다.
```

### 의도하지 않은 타입의 인수를 받았을 때

```javascript
const add = (a, b) => a + b

add(2, "5") // '25'
```

위의 경우처럼 숫자를 예상하고 만들었지만 의도와 다르게 작동할 수 있다. 인수가 적절하게 들어갔는지 함수에서 조건문으로 확인해야 하거나, 런타임에 발견하게 되는 문제가 있다.

정적 타입을 선언할 수 있는 타입스트립트를 사용하면 이런 문제들을 방지할 수 있다.

## 반환문

반환문은 return 키워드와 표현식으로 이루어진다.
반환문은 함수의 실행을 중단하고 빠져나가기 때문에 만약 반환문 뒤에 다른 문들이 오더라도 무시된다.

```javascript
const add = (a, b) => {
  return a + b
  a++ //무시된다.
}

add(1, 2) //3

const add = (a, b) => {
  return //여기서 줄바꿈을 하면 자동으로 return 뒤에 세미콜론이 붙는 형태가 되어 밑의 문들이 모두 무시된다.
  a + b //여기부터 무시된다.
  a++
}

add(1, 2) //undefined //리턴문 뒤에 반환값이 없으면 undefined가 반환된다.
```
