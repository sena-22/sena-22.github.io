---
title: "[Programmers] 21. 최소직사각형
  (javascript)"
excerpt: "최소직사각형"

categories:
  - programmers
tags:
  - [study, recursive, javascript, Lv.1]

toc: true
toc_sticky: true

date: 2023-03-17
last_modified_at: 2023-03-17
---

## 🤔 문제

명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.

아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.

| 명함 번호 | 가로 길이 | 세로 길이 |
| --------- | --------- | --------- |
| 1         | 60        | 50        |
| 2         | 30        | 70        |
| 3         | 60        | 30        |
| 4         | 80        | 40        |

가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.

모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.

## 제한사항

- sizes의 길이는 1 이상 10,000 이하입니다.
- sizes의 원소는 [w, h] 형식입니다.
- w는 명함의 가로 길이를 나타냅니다.
- h는 명함의 세로 길이를 나타냅니다.
- w와 h는 1 이상 1,000 이하인 자연수입니다.

## 입출력 예시

| s                                        | n    |
| ---------------------------------------- | ---- |
| [[60, 50], [30, 70], [60, 30], [80, 40]] | 4000 |

## 의사코드

- 배열을 순회하면서 안쪽 배열의 가로와 세로 길이를 오름차순으로 정렬해준다.
- 정렬된 배열을 for문으로 돌면서
- 구조분해할당을 이용해 가로와 세로 길이를 꺼낸다.
- 가로, 세로 길이를 선언해두고 현재 선택된 길이가 더 크면 바꿔준다.
- 최종 선택된 가로와 세로 길이를 곱해서 리턴한다.

## 제출한 답

```javascript
function solution(sizes) {
  let w = 0
  let h = 0
  sizes.map((size) => size.sort((a, b) => a - b))
  for (let i = 0; i < sizes.length; i++) {
    let [sizeW, sizeH] = sizes[i]
    if (sizeW > w) w = sizeW
    if (sizeH > h) h = sizeH
  }
  return w * h
}
```

- 지갑의 가로와 세로를 정렬하는 이유는 눕혀서 수납할 경우를 대비하기 위해서이다.

💡 알고리즘 스터디 Recursive에서 공부한 내용 정리
{: .notice--danger}
