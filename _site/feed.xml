<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-21T20:52:02+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Reyna</title><subtitle>frontend devleopment</subtitle><author><name>Reyna</name></author><entry><title type="html">[typescript] 제네릭(Generics)</title><link href="http://localhost:4000/typescript/generics/" rel="alternate" type="text/html" title="[typescript] 제네릭(Generics)" /><published>2023-03-21T00:00:00+09:00</published><updated>2023-03-21T00:00:00+09:00</updated><id>http://localhost:4000/typescript/generics</id><content type="html" xml:base="http://localhost:4000/typescript/generics/"><![CDATA[<p><img src="https://user-images.githubusercontent.com/110877564/226537175-291666d8-03bd-4e58-9dff-8c33f3ac133b.png" /></p>

<h2 id="제네릭">제네릭</h2>

<p>타입을 <strong>함수의 파라미터</strong>처럼 사용하게 해주는 타입을 말한다.</p>

<h2 id="제네릭-사용방법">제네릭 사용방법</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getInfo</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">info</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">info</span>
<span class="p">}</span>

<span class="cm">/* 함수를 호출할 때 타입 정의 */</span>
<span class="nx">getInfo</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">"</span><span class="s2">jack</span><span class="dl">"</span><span class="p">)</span>
<span class="nx">getInfo</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<p>제네릭은 함수를 호출할 때 타입이 동적으로 결정된다.</p>

<h3 id="-any를-사용하면-되지-않을까">🤔 any를 사용하면 되지 않을까?</h3>

<p>제네릭을 사용하지 않더라도 any 타입을 사용하면 여러 타입을 받을 수 있다. 하지만 any는 타입 검사를 하지 않고, 제네릭은 입력값과 출력값의 타입이 적절한지 검사한다는 차이점이 있다. 제네릭을 사용하게 되면 함수를 호출할 때 넘긴 타입으로 타입스크립트가 타입을 추정하여 검사할 수 있게 된다.</p>

<h2 id="인터페이스에-제네릭-선언하기">인터페이스에 제네릭 선언하기</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Dropdown</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="nx">T</span>
  <span class="na">selected</span><span class="p">:</span> <span class="nx">boolean</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">obj</span><span class="p">:</span> <span class="nx">Dropdown</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
  <span class="na">selected</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="제네릭에-타입-제한하기-1">제네릭에 타입 제한하기 1</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">logText</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">text</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]):</span> <span class="nx">T</span><span class="p">[]</span> <span class="p">{</span>
  <span class="c1">//제네릭의 타입이 배열이라 length 프로퍼티를 사용할 수 있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">text</span>
<span class="p">}</span>
</code></pre></div></div>

<p>만약 타입을 제한하지 않는다면 에러가 발생한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">logText</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">text</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="c1">//error: Property 'length' does not exist on type 'T'.</span>
  <span class="k">return</span> <span class="nx">text</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="제네릭에-타입-제한하기-2---정의된-타입-이용하기">제네릭에 타입 제한하기 2 - 정의된 타입 이용하기</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">LengthType</span> <span class="p">{</span>
  <span class="nl">length</span><span class="p">:</span> <span class="kr">number</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">logTextLength</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">LengthType</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">text</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="nx">text</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">return</span> <span class="nx">text</span>
<span class="p">}</span>

<span class="nx">logTextLength</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// 문자열은 length 프로퍼티를 가짐</span>
<span class="nx">logTextLength</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// error: 숫자는 length 프로퍼티 없음</span>
<span class="nx">logTextLength</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="mi">10</span> <span class="p">})</span>
<span class="nx">logTextLength</span><span class="p">({</span> <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">blue</span><span class="dl">"</span> <span class="p">})</span> <span class="c1">//error: length 프로퍼티가 정의되어 있지 않으므로 에러 발생</span>
</code></pre></div></div>

<h2 id="제네릭에-타입-제한하기-3---keyof">제네릭에 타입 제한하기 3 - keyof</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Item</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span>
  <span class="nx">price</span><span class="p">:</span> <span class="kr">number</span>
  <span class="nx">stock</span><span class="p">:</span> <span class="kr">number</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">getItemOption</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="kr">keyof</span> <span class="nx">Item</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">itemOption</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">itemOption</span>
<span class="p">}</span>
<span class="c1">//아이템의 key 중에 한가지가 들어갈 수 있다.</span>
<span class="nx">getItemOption</span><span class="p">(</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">)</span>
<span class="nx">getItemOption</span><span class="p">(</span><span class="dl">"</span><span class="s2">10</span><span class="dl">"</span><span class="p">)</span> <span class="c1">//error:Argument of type '"10"' is not assignable to parameter of type 'keyof Item'.</span>
</code></pre></div></div>

<p class="notice--danger">💡 참고 <br />
<a href="https://joshua1988.github.io/ts/guide/generics.html#%EC%A0%9C%EB%84%A4%EB%A6%AD-generics-%EC%9D%98-%EC%82%AC%EC%A0%84%EC%A0%81-%EC%A0%95%EC%9D%98">타입스크립트 핸드북</a> <br />
<a href="https://kyounghwan01.github.io/blog/TS/fundamentals/generic/">타입스크립트 제네릭</a></p>]]></content><author><name>Reyna</name></author><category term="typescript" /><category term="typescript" /><category term="generics" /><summary type="html"><![CDATA[generics]]></summary></entry><entry><title type="html">리액트에 Sass 설치하기</title><link href="http://localhost:4000/notes/sass/" rel="alternate" type="text/html" title="리액트에 Sass 설치하기" /><published>2023-03-21T00:00:00+09:00</published><updated>2023-03-21T00:00:00+09:00</updated><id>http://localhost:4000/notes/sass</id><content type="html" xml:base="http://localhost:4000/notes/sass/"><![CDATA[<h2 id="sass-설치하기">Sass 설치하기</h2>

<p><code class="language-plaintext highlighter-rouge">npm i node-sass</code></p>

<p class="notice--primary"><a href="https://www.npmjs.com/package/node-sass">npm node-sass</a> <br /></p>

<h2 id="확장자-변경하기">확장자 변경하기</h2>

<p>확장자를 <code class="language-plaintext highlighter-rouge">css</code>가 아니라 <code class="language-plaintext highlighter-rouge">scss</code>로 바꿔준다.</p>

<p><img width="158" alt="스크린샷 2023-03-21 오후 8 15 21" src="https://user-images.githubusercontent.com/110877564/226590357-f91ec34c-5c84-4e76-a88f-437fff7f6d32.png" /></p>

<p>마찬가지로 import할 때도 <code class="language-plaintext highlighter-rouge">css</code>에서 <code class="language-plaintext highlighter-rouge">scss</code>로 변경한다.</p>

<p><img width="205" alt="스크린샷 2023-03-21 오후 8 22 37" src="https://user-images.githubusercontent.com/110877564/226592312-562bd57f-9762-4e56-8733-c68fcc3d57d5.png" /></p>]]></content><author><name>Reyna</name></author><category term="notes" /><category term="Sass" /><summary type="html"><![CDATA[Sass]]></summary></entry><entry><title type="html">[Discord Clone] 리액트 사이드바 만들기</title><link href="http://localhost:4000/lecture/discord-clone-1/" rel="alternate" type="text/html" title="[Discord Clone] 리액트 사이드바 만들기" /><published>2023-03-21T00:00:00+09:00</published><updated>2023-03-21T00:00:00+09:00</updated><id>http://localhost:4000/lecture/discord-clone-1</id><content type="html" xml:base="http://localhost:4000/lecture/discord-clone-1/"><![CDATA[<p><img src="https://user-images.githubusercontent.com/110877564/226597954-5de7a38a-1e6b-4374-9e92-f3321e015744.png" /></p>]]></content><author><name>Reyna</name></author><category term="lecture" /><category term="udemy" /><category term="clone" /><category term="sidebar" /><category term="html" /><category term="css" /><summary type="html"><![CDATA[사이드바 컴포넌트 만들기]]></summary></entry><entry><title type="html">[Programmers] 22. 비밀 지도 (javascript)</title><link href="http://localhost:4000/programmers/secret-map/" rel="alternate" type="text/html" title="[Programmers] 22. 비밀 지도 (javascript)" /><published>2023-03-20T00:00:00+09:00</published><updated>2023-03-20T00:00:00+09:00</updated><id>http://localhost:4000/programmers/secret-map</id><content type="html" xml:base="http://localhost:4000/programmers/secret-map/"><![CDATA[<h2 id="-문제">🤔 문제</h2>

<p>네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.</p>

<p>지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 “공백”(“ “) 또는 “벽”(“#”) 두 종류로 이루어져 있다.
전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 “지도 1”과 “지도 2”라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
“지도 1”과 “지도 2”는 각각 정수 배열로 암호화되어 있다.
암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.</p>

<p><img src="http://t1.kakaocdn.net/welcome2018/secret8.png" width="300px" height="500px" />
네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.</p>

<h2 id="입력-형식">입력 형식</h2>

<p>입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.</p>

<ul>
  <li>1 ≦ n ≦ 16</li>
  <li>arr1, arr2는 길이 n인 정수 배열로 주어진다.</li>
  <li>정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.</li>
</ul>

<h2 id="출력-형식">출력 형식</h2>

<p>원래의 비밀지도를 해독하여 ‘#’, 공백으로 구성된 문자열 배열로 출력하라.</p>

<h2 id="입출력-예시">입출력 예시</h2>

<table>
  <thead>
    <tr>
      <th>매개변수</th>
      <th>값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>n</td>
      <td>5</td>
    </tr>
    <tr>
      <td>arr1</td>
      <td>[9, 20, 28, 18, 11]</td>
    </tr>
    <tr>
      <td>arr2</td>
      <td>[30, 1, 21, 17, 28]</td>
    </tr>
    <tr>
      <td>출력</td>
      <td>[”#####”,”# # #”, “### #”, “# ##”, “#####”]</td>
    </tr>
  </tbody>
</table>

<h2 id="의사코드">의사코드</h2>

<ul>
  <li>배열을 순회하면서 2진수로 바꾼다</li>
  <li>앞이 0인 경우 사라지므로 지도의 크기만큼 앞을 0으로 채운다(padStart 사용)</li>
  <li>2진수로 바꾼 배열을 순회하면서 2진법으로 변환된 숫자(ex.00100)를 다시 하나씩 순회한다.</li>
  <li>빈 문자열을 하나 선언한다.</li>
  <li>첫번째나 두번째 배열 중 하나에 1이 있다면 문자열에 ‘#’을 추가하고, 둘다 1이 없으면 공백을 추가한다.</li>
  <li>만들어진 줄을 결과 배열에 추가한다.</li>
</ul>

<h2 id="제출한-답">제출한 답</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">arr1</span><span class="p">,</span> <span class="nx">arr2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">const</span> <span class="nx">toBinary</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">newArr</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">el</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">el</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">padStart</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="nx">newArr</span>
  <span class="p">}</span>

  <span class="nx">arr1</span> <span class="o">=</span> <span class="nx">toBinary</span><span class="p">(</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
  <span class="nx">arr2</span> <span class="o">=</span> <span class="nx">toBinary</span><span class="p">(</span><span class="nx">arr2</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">line</span> <span class="o">=</span> <span class="dl">""</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span> <span class="o">||</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">arr2</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]))</span> <span class="p">{</span>
        <span class="nx">line</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2">#</span><span class="dl">"</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">line</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">line</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="notice--danger">💡 알고리즘 스터디 Recursive에서 공부한 내용 정리</p>]]></content><author><name>Reyna</name></author><category term="programmers" /><category term="study" /><category term="recursive" /><category term="javascript" /><category term="Lv.1" /><summary type="html"><![CDATA[비밀 지도]]></summary></entry><entry><title type="html">[Deep Dive] 13. 생성자 함수에 의한 객체 생성</title><link href="http://localhost:4000/javascript/2-new-Object/" rel="alternate" type="text/html" title="[Deep Dive] 13. 생성자 함수에 의한 객체 생성" /><published>2023-03-17T00:00:00+09:00</published><updated>2023-03-17T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2-new-Object</id><content type="html" xml:base="http://localhost:4000/javascript/2-new-Object/"><![CDATA[<h2 id="object-생성자-함수">Object 생성자 함수</h2>

<ul>
  <li>new 연산자와 Object 생성자 함수를 이용하여 객체를 만들 수 있다. 이때 만들어지는 객체는 빈 객체이다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">character</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">()</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">character</span><span class="p">)</span> <span class="c1">// {}</span>
</code></pre></div></div>

<p>만들어진 객체에 프로퍼티나 메서드를 추가할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">character</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">jack</span><span class="dl">"</span> <span class="c1">//프로퍼티 추가</span>
<span class="nx">character</span><span class="p">.</span><span class="nx">go</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">go!</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// 메서드 추가</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">character</span><span class="p">)</span> <span class="c1">//{name: 'jack', go: ƒ}</span>
</code></pre></div></div>

<p>생성자 함수(constructor function)는 new 연산자와 함께 호출하여 객체를 생성하는 함수를 말한다. 일반적으로 대문자로 시작한다. 생성자 함수에 의해 만들어진 객체를 인스턴스라고 한다. 위의 코드에서 <code class="language-plaintext highlighter-rouge">character</code>는 Object 생성자 함수에 의해 만들어진 인스턴스가 된다.</p>

<h2 id="객체-리터럴-vs-생성자-함수를-이용한-객체-생성">객체 리터럴 vs 생성자 함수를 이용한 객체 생성</h2>

<p>객체 리터럴로 객체를 생성하면 간단하지만, 여러 개의 비슷한 객체를 만들 때는 비효율적이다. 생성자 함수를 이용하면 틀을 만들어두는 것과 비슷하게 프로퍼티 구조가 동일한 객체(인스턴스)를 여러 개 만들 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Character</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">hp</span> <span class="o">=</span> <span class="mi">10</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">character</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Character</span><span class="p">(</span><span class="dl">"</span><span class="s2">jack</span><span class="dl">"</span><span class="p">)</span>
<span class="kd">let</span> <span class="nx">character2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Character</span><span class="p">(</span><span class="dl">"</span><span class="s2">rin</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">character</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="c1">//jack</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">character</span><span class="p">.</span><span class="nx">hp</span><span class="p">)</span> <span class="c1">//10</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">character2</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="c1">//rin</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">character2</span><span class="p">.</span><span class="nx">hp</span><span class="p">)</span> <span class="c1">//10</span>
</code></pre></div></div>

<p>이때 this는 나중에 생성할 인스턴스를 가리킨다.</p>

<h2 id="생성자-함수의-인스턴스-생성-과정">생성자 함수의 인스턴스 생성 과정</h2>

<h3 id="1-인스턴스-생성과-this-바인딩">1. 인스턴스 생성과 this 바인딩</h3>

<ul>
  <li>빈 객체를 만들어 this에 할당한다. 이 과정은 암묵적으로 일어난다.</li>
</ul>

<h3 id="2-인스턴스-초기화">2. 인스턴스 초기화</h3>

<ul>
  <li>this에 바인딩된 인스턴스에 프로퍼티나 메서드를 추가하고, 인수로 받은 초기값을 인스턴스 프로퍼티에 할당한다.</li>
</ul>

<h3 id="3-인스턴스-반환">3. 인스턴스 반환</h3>

<ul>
  <li>인스턴스가 바인딩된 this를 반환한다. 여기도 암묵적으로 일어난다. 이때 만약 return 문을 작성하면 암묵적으로 반환되는 인스턴스는 무시되고, 명시적으로 작성한 return 문이 실행된다. 따라서 생성자 함수 내부에서 return 문을 생략해야 생각한 대로 작동할 것이다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Character</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//this = {} //1. 빈 객체를 만들어 this에 할당</span>

  <span class="c1">// 2. 인스턴스 초기화</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">hp</span> <span class="o">=</span> <span class="mi">10</span>

  <span class="c1">// 3. 인스턴스 반환</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="constructor-vs-non-constructor">constructor vs non-constructor</h2>

<ul>
  <li>non-constructor 함수는 생성자 함수로 호출할 수 없다.</li>
  <li>
    <p>constructor와 non-constructor 함수는 <mark>함수를 정의하는 방식</mark>에 따라 결정된다.</p>
  </li>
  <li>constructor : 함수 선언문, 함수 표현식, 클래스</li>
  <li>non-constructor : 화살표 함수, 메서드(메서드 축약 표현)</li>
</ul>

<p>따라서 화살표 함수와 메서드 축약 표현으로 정의된 함수는 new를 붙여 생성자 함수로 호출할 수 없다.</p>

<h2 id="newtarget">new.target</h2>

<p><code class="language-plaintext highlighter-rouge">new.target</code> 프로퍼티를 사용하면 함수가 new와 함께 호출되었는지 확인할 수 있다.</p>

<ul>
  <li>new 연산자와 함께 함수가 호출되면 함수 내부의 <code class="language-plaintext highlighter-rouge">new.target</code>은 자기 자신을 가리킨다.</li>
  <li>일반함수로 호출된 <code class="language-plaintext highlighter-rouge">new.target</code>은 <code class="language-plaintext highlighter-rouge">undefined</code>이다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Character</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">Character</span><span class="p">()</span> <span class="c1">//undefined (일반 함수로 호출)</span>
<span class="k">new</span> <span class="nx">Character</span><span class="p">()</span> <span class="c1">// ƒ Character() {...} (생성자 함수로 호출)</span>
</code></pre></div></div>

<p>생성자 함수를 호출하는 과정에서 new가 없어도 함수 내부에서 재귀적으로 붙일 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Character</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// new 없이 호출해도</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Character</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="c1">// new를 붙여줌</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">character</span> <span class="o">=</span> <span class="nx">Character</span><span class="p">(</span><span class="dl">"</span><span class="s2">jack</span><span class="dl">"</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">character</span><span class="p">)</span> <span class="c1">// Character {name: 'jack'}</span>
</code></pre></div></div>

<p>하지만 new를 붙여서 객체를 생성하는 것이 더 명시적이다.</p>

<ul>
  <li>빌트인 생성자 함수의 경우 new 연산자 없이 호출해도 new가 붙은 것처럼 작동한다.</li>
  <li>하지만 String, Number, Boolean 생성자 함수는 new 연산자 없이 호출하면 문자열, 숫자, 불리언 값을 반환한다. 따라서 타입 변환에도 사용된다.</li>
</ul>]]></content><author><name>Reyna</name></author><category term="javascript" /><category term="javascript" /><summary type="html"><![CDATA[new 연산자와 Object 생성자 함수를 이용하여 객체 만들기]]></summary></entry><entry><title type="html">[Deep Dive] 12. 프로퍼티 어트리뷰트</title><link href="http://localhost:4000/javascript/1-property-attribute/" rel="alternate" type="text/html" title="[Deep Dive] 12. 프로퍼티 어트리뷰트" /><published>2023-03-17T00:00:00+09:00</published><updated>2023-03-17T00:00:00+09:00</updated><id>http://localhost:4000/javascript/1-property-attribute</id><content type="html" xml:base="http://localhost:4000/javascript/1-property-attribute/"><![CDATA[<h1 id="1-내부-슬롯-내부-메서드">1. 내부 슬롯, 내부 메서드</h1>

<h2 id="내부-슬롯-내부-메서드">내부 슬롯, 내부 메서드?</h2>

<ul>
  <li>자바스크립트 엔진의 내부 로직으로, <code class="language-plaintext highlighter-rouge">이중 대괄호([[ ]])</code>로 감싼 것들을 말한다.</li>
  <li>보통은 접근이 불가능하다. 하지만 일부의 내부 슬롯과 메서드들은 간접적으로 접근할 수 있다.</li>
  <li>예를 들어, <code class="language-plaintext highlighter-rouge">[[Prototype]]</code> 내부 슬롯의 경우, <code class="language-plaintext highlighter-rouge">__proto__</code>로 접근이 가능하다.</li>
</ul>

<h1 id="2-프로퍼티-어트리뷰트">2. 프로퍼티 어트리뷰트</h1>

<ul>
  <li>JS 엔진이 관리하는 meta-property를 말한다.</li>
  <li>프로퍼티 생성 시 자동으로 정의되며, 프로퍼티의 상태를 나타낸다.</li>
  <li><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptor</code> 메서드로 간접적으로 확인이 가능하다.</li>
</ul>

<h3 id="objectgetownpropertydescriptor객체의-참조-프로퍼티-키">Object.getOwnPropertyDescriptor(객체의 참조, ‘프로퍼티 키’)</h3>

<p><img src="https://velog.velcdn.com/images/sena-22/post/fdcc88ac-48f1-43bf-9866-16deb4450a85/image.jpeg" alt="" /></p>

<p>-<code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptor</code>는 하나의 프로퍼티에 대해서만 프로퍼티 디스크립터 객체를 반환하지만, <code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptors</code>를 사용하면 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터를 반환한다.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptor</code> 메서드를 사용하면 디스크립터 객체를 반환하는데, 이 객체는 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 제공한다.</p>
</blockquote>

<h1 id="3-데이터-프로퍼티와-접근자-프로퍼티">3. 데이터 프로퍼티와 접근자 프로퍼티</h1>

<h2 id="데이터-프로퍼티">데이터 프로퍼티</h2>

<ul>
  <li>키와 값으로 구성된 일반 프로퍼티</li>
</ul>

<h3 id="데이터-프로퍼티의-프로퍼티-어트리뷰트">데이터 프로퍼티의 프로퍼티 어트리뷰트</h3>

<ol>
  <li>[[Value]]</li>
</ol>

<ul>
  <li>프로퍼티 키를 통해 값에 접근했을 때 반환되는 값</li>
</ul>

<ol>
  <li>[[Writable]]</li>
</ol>

<ul>
  <li>프로퍼티 값의 변경 여부를 나타낸다(boolean)</li>
  <li><code class="language-plaintext highlighter-rouge">false</code>인 경우, 읽기 전용이다.</li>
</ul>

<ol>
  <li>[[Enumerable]]</li>
</ol>

<ul>
  <li>프로퍼티의 열거 가능 여부를 나타낸다</li>
  <li><code class="language-plaintext highlighter-rouge">false</code>인 경우, for…in 문이나 Object.keys 등으로 열거할 수 없다.</li>
</ul>

<ol>
  <li>[[Configurable]]</li>
</ol>

<ul>
  <li>프로퍼티의 재정의 가능 여부</li>
  <li><code class="language-plaintext highlighter-rouge">false</code>인 경우 프로퍼티 삭제, 프로퍼티 어트리뷰트 값을 변경할 수 없다.
([[Writable]]이 <code class="language-plaintext highlighter-rouge">true</code>인 경우 <code class="language-plaintext highlighter-rouge">Value</code> 변경, [[Writable]]을 <code class="language-plaintext highlighter-rouge">false</code>로 변경할 수는 있다.</li>
</ul>

<h2 id="접근자-프로퍼티">접근자 프로퍼티</h2>

<ul>
  <li>접근자 함수(다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출)로 구성된 프로퍼티</li>
</ul>

<h3 id="접근자-프로퍼티의-프로퍼티-어트리뷰트">접근자 프로퍼티의 프로퍼티 어트리뷰트</h3>

<ol>
  <li>[[GEt]]</li>
</ol>

<ul>
  <li>데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수</li>
  <li>접근자 프로퍼티 키로 프로퍼티 값에 접근하면 getter 함수가 호출되고, 그 결과가 프로퍼티 값으로 반환된다.</li>
</ul>

<ol>
  <li>[[Set]]</li>
</ol>

<ul>
  <li>데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수</li>
  <li>접근자 프로퍼티 키로 프로퍼티 값을 저장하면, setter 함수가 호출되고, 그 결과가 프로퍼티 값으로 저장된다.</li>
</ul>

<ol>
  <li>[[Enumerable]]</li>
  <li>[[Configurable]]</li>
</ol>

<ul>
  <li>3, 4번은 데이터 프로퍼티 어트리뷰트와 동일하다.</li>
</ul>

<p class="notice--danger">deep dive 16장 참고</p>]]></content><author><name>Reyna</name></author><category term="javascript" /><category term="javascript" /><category term="property attribute" /><summary type="html"><![CDATA[property attribute]]></summary></entry><entry><title type="html">[Programmers] 21. 최소직사각형 (javascript)</title><link href="http://localhost:4000/programmers/min-rectangle/" rel="alternate" type="text/html" title="[Programmers] 21. 최소직사각형 (javascript)" /><published>2023-03-17T00:00:00+09:00</published><updated>2023-03-17T00:00:00+09:00</updated><id>http://localhost:4000/programmers/min-rectangle</id><content type="html" xml:base="http://localhost:4000/programmers/min-rectangle/"><![CDATA[<h2 id="-문제">🤔 문제</h2>

<p>명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.</p>

<p>아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.</p>

<table>
  <thead>
    <tr>
      <th>명함 번호</th>
      <th>가로 길이</th>
      <th>세로 길이</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>60</td>
      <td>50</td>
    </tr>
    <tr>
      <td>2</td>
      <td>30</td>
      <td>70</td>
    </tr>
    <tr>
      <td>3</td>
      <td>60</td>
      <td>30</td>
    </tr>
    <tr>
      <td>4</td>
      <td>80</td>
      <td>40</td>
    </tr>
  </tbody>
</table>

<p>가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.</p>

<p>모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.</p>

<h2 id="제한사항">제한사항</h2>

<ul>
  <li>sizes의 길이는 1 이상 10,000 이하입니다.</li>
  <li>sizes의 원소는 [w, h] 형식입니다.</li>
  <li>w는 명함의 가로 길이를 나타냅니다.</li>
  <li>h는 명함의 세로 길이를 나타냅니다.</li>
  <li>w와 h는 1 이상 1,000 이하인 자연수입니다.</li>
</ul>

<h2 id="입출력-예시">입출력 예시</h2>

<table>
  <thead>
    <tr>
      <th>s</th>
      <th>n</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[[60, 50], [30, 70], [60, 30], [80, 40]]</td>
      <td>4000</td>
    </tr>
  </tbody>
</table>

<h2 id="의사코드">의사코드</h2>

<ul>
  <li>배열을 순회하면서 안쪽 배열의 가로와 세로 길이를 오름차순으로 정렬해준다.</li>
  <li>정렬된 배열을 for문으로 돌면서</li>
  <li>구조분해할당을 이용해 가로와 세로 길이를 꺼낸다.</li>
  <li>가로, 세로 길이를 선언해두고 현재 선택된 길이가 더 크면 바꿔준다.</li>
  <li>최종 선택된 가로와 세로 길이를 곱해서 리턴한다.</li>
</ul>

<h2 id="제출한-답">제출한 답</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">solution</span><span class="p">(</span><span class="nx">sizes</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">w</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">h</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="nx">sizes</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">size</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">size</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">))</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">sizes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="p">[</span><span class="nx">sizeW</span><span class="p">,</span> <span class="nx">sizeH</span><span class="p">]</span> <span class="o">=</span> <span class="nx">sizes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">sizeW</span> <span class="o">&gt;</span> <span class="nx">w</span><span class="p">)</span> <span class="nx">w</span> <span class="o">=</span> <span class="nx">sizeW</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">sizeH</span> <span class="o">&gt;</span> <span class="nx">h</span><span class="p">)</span> <span class="nx">h</span> <span class="o">=</span> <span class="nx">sizeH</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">w</span> <span class="o">*</span> <span class="nx">h</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>지갑의 가로와 세로를 정렬하는 이유는 눕혀서 수납할 경우를 대비하기 위해서이다.</li>
</ul>

<p class="notice--danger">💡 알고리즘 스터디 Recursive에서 공부한 내용 정리</p>]]></content><author><name>Reyna</name></author><category term="programmers" /><category term="study" /><category term="recursive" /><category term="javascript" /><category term="Lv.1" /><summary type="html"><![CDATA[최소직사각형]]></summary></entry><entry><title type="html">[Programmers] 21. 시저 암호 (javascript)</title><link href="http://localhost:4000/programmers/3-caesar-cipher/" rel="alternate" type="text/html" title="[Programmers] 21. 시저 암호 (javascript)" /><published>2023-03-16T00:00:00+09:00</published><updated>2023-03-17T00:00:00+09:00</updated><id>http://localhost:4000/programmers/3-caesar-cipher</id><content type="html" xml:base="http://localhost:4000/programmers/3-caesar-cipher/"><![CDATA[<h2 id="-문제">🤔 문제</h2>

<p>어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 “AB”는 1만큼 밀면 “BC”가 되고, 3만큼 밀면 “DE”가 됩니다. “z”는 1만큼 밀면 “a”가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.</p>

<h2 id="제한사항">제한사항</h2>

<ul>
  <li>공백은 아무리 밀어도 공백입니다.</li>
  <li>s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.</li>
  <li>s의 길이는 8000이하입니다.</li>
  <li>n은 1 이상, 25이하인 자연수입니다.</li>
</ul>

<h2 id="입출력-예시">입출력 예시</h2>

<table>
  <thead>
    <tr>
      <th>s</th>
      <th>n</th>
      <th>result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>“AB”</td>
      <td>1</td>
      <td>“BC”</td>
    </tr>
    <tr>
      <td>“z”</td>
      <td>1</td>
      <td>“a”</td>
    </tr>
    <tr>
      <td>“a B z”</td>
      <td>4</td>
      <td>“e F d”</td>
    </tr>
  </tbody>
</table>

<h2 id="의사코드">의사코드</h2>

<ul>
  <li>문자열을 모두 유니코드로 바꿔준다. <code class="language-plaintext highlighter-rouge">String.prototype.charCodeAt()</code> 메서드를 사용하면 된다.</li>
  <li>유니코드로 변환된 문자열을 순환하면서 주어진 숫자(n)만큼 더해준다.</li>
  <li>공백인 경우 아무리 밀어도 공백이기 때문에 그대로 반환한다. 공백은 32이다.</li>
  <li>유니코드에 알파벳만 있는 것은 아니다. 예를 들어 ‘!’의 경우 33이다.</li>
  <li>따라서 알파벳 범위를 벗어난 경우, 즉 z를 넘어간 경우 다시 범위로 돌려주기 위해 26을 뺀다.
<img width="261" alt="스크린샷 2023-03-17 오전 12 54 10" src="https://user-images.githubusercontent.com/110877564/225677281-09a61940-0fba-4037-a1a4-c0c6352c136c.png" /></li>
  <li>모든 유니코드를 다 밀면 다시 문자열로 돌려줘야 한다. <code class="language-plaintext highlighter-rouge">String.fromCharCode()</code> 메서드를 사용하면 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">.join('')</code>으로 문자열을 다시 붙여준다.</li>
</ul>

<h2 id="제출한-답">제출한 답</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">charCode</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">s</span><span class="p">].</span><span class="nx">map</span><span class="p">((</span><span class="nx">el</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">el</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">el</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">===</span> <span class="mi">32</span><span class="p">)</span> <span class="k">return</span> <span class="nx">cur</span>
    <span class="k">if</span> <span class="p">((</span><span class="nx">cur</span> <span class="o">&gt;=</span> <span class="mi">97</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span> <span class="o">+</span> <span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">122</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">&lt;</span> <span class="mi">97</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span> <span class="o">+</span> <span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">))</span>
      <span class="k">return</span> <span class="nx">cur</span> <span class="o">-</span> <span class="mi">26</span> <span class="o">+</span> <span class="nx">n</span>
    <span class="k">else</span> <span class="k">return</span> <span class="nx">cur</span> <span class="o">+</span> <span class="nx">n</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="nx">charCode</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">el</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="nx">el</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>알파벳의 유니코드를 외우고 있지 않은 이상 코드에서 각각 구하는 방식으로 푸는 게 맞나 싶다. 알파벳을 전부 변수에 할당해서 푸는 경우도 있는데 숫자가 한정되어 있어서 이 방식도 있긴 하다.</li>
  <li>두 번째 if문은 (1)소문자인데 밀면 소문자를 벗어나거나, (2) 대문자인데 밀면 대문자를 벗어나거나 둘 중에 하나를 충족할 경우 실행된다.</li>
</ul>

<p class="notice--danger">💡 알고리즘 스터디 Recursive에서 공부한 내용 정리</p>]]></content><author><name>Reyna</name></author><category term="programmers" /><category term="study" /><category term="recursive" /><category term="javascript" /><category term="Lv.1" /><summary type="html"><![CDATA[시저 암호]]></summary></entry><entry><title type="html">[Programmers] 19. 이상한 문자 만들기 (javascript)</title><link href="http://localhost:4000/programmers/1-weird-string/" rel="alternate" type="text/html" title="[Programmers] 19. 이상한 문자 만들기 (javascript)" /><published>2023-03-16T00:00:00+09:00</published><updated>2023-03-16T00:00:00+09:00</updated><id>http://localhost:4000/programmers/1-weird-string</id><content type="html" xml:base="http://localhost:4000/programmers/1-weird-string/"><![CDATA[<h2 id="-문제">🤔 문제</h2>

<p>문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.</p>

<h2 id="제한사항">제한사항</h2>

<ul>
  <li>문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다.</li>
  <li>첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다.</li>
</ul>

<h2 id="입출력-예시">입출력 예시</h2>

<table>
  <thead>
    <tr>
      <th>s</th>
      <th>return</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>“try hello world”</td>
      <td>“TrY HeLlO WoRlD”</td>
    </tr>
  </tbody>
</table>

<h2 id="의사코드">의사코드</h2>

<ul>
  <li>split(‘ ‘)을 사용해서 단어를 공백 기준으로 쪼갠다.</li>
  <li>각 단어를 다시 split을 이용해서 한 단어씩 쪼개고, 각 단어를 map으로 돌면서 인덱스가 짝수인 경우 대문자로, 홀수인 경우 소문자로 바꾼다.</li>
  <li>문자열을 다시 단어로 합치고(<code class="language-plaintext highlighter-rouge">join('')</code>), 합친 배열을 다시 합쳐서 하나의 배열로 만든다.(<code class="language-plaintext highlighter-rouge">join(' ')</code>)</li>
</ul>

<h2 id="제출한-답">제출한 답</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">s</span>
    <span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="c1">// ['try', 'hello', 'world']</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="nx">i</span>
        <span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">)</span> <span class="c1">// [['t', 'r', 'y'], ['h', 'e', 'l', 'l', 'o'],['w', 'o', 'r', 'l', 'd']]</span>
        <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">j</span><span class="p">,</span> <span class="nx">idx</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">idx</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">j</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span> <span class="p">:</span> <span class="nx">j</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">()))</span> <span class="c1">// ['T', 'r', 'Y']...</span>
        <span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="notice--danger">💡 알고리즘 스터디 Recursive에서 공부한 내용 정리</p>]]></content><author><name>Reyna</name></author><category term="programmers" /><category term="study" /><category term="recursive" /><category term="javascript" /><category term="Lv.1" /><summary type="html"><![CDATA[이상한 문자 만들기]]></summary></entry><entry><title type="html">[Programmers] 20. 예산 (javascript)</title><link href="http://localhost:4000/programmers/2-budget/" rel="alternate" type="text/html" title="[Programmers] 20. 예산 (javascript)" /><published>2023-03-16T00:00:00+09:00</published><updated>2023-03-16T00:00:00+09:00</updated><id>http://localhost:4000/programmers/2-budget</id><content type="html" xml:base="http://localhost:4000/programmers/2-budget/"><![CDATA[<h2 id="-문제">🤔 문제</h2>

<p>S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.</p>

<p>물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.</p>

<p>부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.</p>

<h2 id="제한사항">제한사항</h2>

<ul>
  <li>d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.</li>
  <li>d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.</li>
  <li>budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.</li>
</ul>

<h2 id="입출력-예시">입출력 예시</h2>

<table>
  <thead>
    <tr>
      <th>d</th>
      <th>budget</th>
      <th>return</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[1,3,2,5,4]</td>
      <td>9</td>
      <td>3</td>
    </tr>
    <tr>
      <td>[2,2,3,3]</td>
      <td>10</td>
      <td>4</td>
    </tr>
  </tbody>
</table>

<h2 id="의사코드">의사코드</h2>

<ul>
  <li>배열을 오름차순으로 정렬한다. 작은 금액부터 예산을 분배해야 많은 부서에 물품을 지원할 수 있다.</li>
  <li>지급액(sum)이 예산보다 작은 동안 반복문을 돌린다</li>
  <li>반복문 안에서 현재 지급액에 새로운 금액을 추가했을 때 예산을 초과하거나, 배열을 전부 순회했을 때(예산을 다 써도 남는 경우) 바로 리턴한다. 이때의 i가 예산을 지급할 부서의 개수가 된다.</li>
  <li>위의 조건문에 해당하지 않는 경우 지급액에 현재 금액을 더하고 부서 개수를 추가한다.</li>
</ul>

<h2 id="제출한-답">제출한 답</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">solution</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">budget</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="nx">d</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">&lt;</span> <span class="nx">budget</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">+</span> <span class="nx">d</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">budget</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">d</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">i</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">d</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="nx">i</span><span class="o">++</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="notice--danger">💡 알고리즘 스터디 Recursive에서 공부한 내용 정리</p>]]></content><author><name>Reyna</name></author><category term="programmers" /><category term="study" /><category term="recursive" /><category term="javascript" /><category term="Lv.1" /><summary type="html"><![CDATA[예산]]></summary></entry></feed>