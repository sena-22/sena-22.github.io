<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-18T06:23:18+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Reyna</title><subtitle>frontend devleopment</subtitle><author><name>Reyna</name></author><entry><title type="html">[Mini Project] 감성 일기장 업그레이드 5. Zustand 적용해보기</title><link href="http://localhost:4000/mini%20project/emotion-diary-5/" rel="alternate" type="text/html" title="[Mini Project] 감성 일기장 업그레이드 5. Zustand 적용해보기" /><published>2023-04-18T00:00:00+09:00</published><updated>2023-04-18T00:00:00+09:00</updated><id>http://localhost:4000/mini%20project/emotion-diary-5</id><content type="html" xml:base="http://localhost:4000/mini%20project/emotion-diary-5/"><![CDATA[<p>감성 일기장에 Zustand를 적용해보려고 한다.</p>

<p>현재 감성 일기장은 context API를 이용해서 상태를 관리하고 있다. context API는 최상단의 state를 업데이트하면 하위 컴포넌트가 리렌더링되는 단점을 가지고 있고, 이를 방어할 방법이 메모이제이션 뿐이라는 단점을 가지고 있기 때문에 더 복잡한 프로젝트에서는 다른 상태 관리 라이브러리가 필요하다고 해서, 이번 기회에 써보기로 했다.</p>

<p>상태 관리 라이브러리에 여러 종류가 있지만, 되도록 가벼운 종류를 써보고 싶어서 zustand를 선택했다.</p>

<p class="notice--primary">참고한 글
<a href="https://marcus-log.dev/zustand">크레딧잡 새로운 상태 관리를 위한 여정 (feat. Zustand)</a></p>

<h1 id="zustand-설치">zustand 설치</h1>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npm</span> <span class="nx">i</span> <span class="nx">zustand</span>
</code></pre></div></div>

<p class="notice--primary"><a href="https://www.npmjs.com/package/zustand?activeTab=readme">zustand npm</a></p>

<h1 id="스토어-생성">스토어 생성</h1>]]></content><author><name>Reyna</name></author><category term="mini project" /><category term="project" /><category term="wanted challenge" /><category term="react" /><category term="typescript" /><summary type="html"><![CDATA[wanted challenge]]></summary></entry><entry><title type="html">[react + typescript] kakao map api 사용하기</title><link href="http://localhost:4000/notes/kakao-map/" rel="alternate" type="text/html" title="[react + typescript] kakao map api 사용하기" /><published>2023-04-17T00:00:00+09:00</published><updated>2023-04-17T00:00:00+09:00</updated><id>http://localhost:4000/notes/kakao-map</id><content type="html" xml:base="http://localhost:4000/notes/kakao-map/"><![CDATA[<h1 id="카카오-맵-띄우기">카카오 맵 띄우기</h1>

<p><a href="https://apis.map.kakao.com/web/guide/">kakao map api</a>에 나온 과정을 참고했다.</p>

<h2 id="indexhtml에-추가">index.html에 추가</h2>

<p>https://developers.kakao.com/에서 앱을 생성한 뒤 Javascript 키를 발급 받는다.
index.html의 &lt;head&gt;안에 다음 코드를 넣어준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span>
  <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text/javascript</span><span class="dl">"</span>
  <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">//dapi.kakao.com/v2/maps/sdk.js?appkey=발급받은 APP KEY를 넣으시면 됩니다.</span><span class="dl">"</span>
<span class="o">&gt;&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>

<h2 id="지도-영역-만들고-불러오기">지도 영역 만들고 불러오기</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">container</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">map</span><span class="dl">"</span><span class="p">)</span>
    <span class="kd">const</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">center</span><span class="p">:</span> <span class="k">new</span> <span class="nx">kakao</span><span class="p">.</span><span class="nx">maps</span><span class="p">.</span><span class="nx">LatLng</span><span class="p">(</span><span class="mf">37.365264512305174</span><span class="p">,</span> <span class="mf">127.10676860117488</span><span class="p">),</span>
      <span class="na">level</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">kakao</span><span class="p">.</span><span class="nx">maps</span><span class="p">.</span><span class="nb">Map</span><span class="p">(</span><span class="nx">container</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
  <span class="p">},</span> <span class="p">[])</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">App</span><span class="dl">"</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">id</span><span class="o">=</span><span class="dl">"</span><span class="s2">map</span><span class="dl">"</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">map</span><span class="dl">"</span><span class="o">&gt;&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이때 상단에서 kakao를 불러와야 한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span><span class="nx">kakao</span><span class="p">}</span> <span class="o">=</span> <span class="nb">window</span>
</code></pre></div></div>

<p>window에 타입이 없다고 에러가 뜰 것이다. 타입을 추가해주면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span><span class="nx">kakao</span><span class="p">}</span> <span class="o">=</span> <span class="nb">window</span>
</code></pre></div></div>

<p>##</p>

<p>참고</p>

<p>https://apis.map.kakao.com/web/guide/
https://react-kakao-maps-sdk.jaeseokim.dev/docs/sample/library/keywordBasic
https://apis.map.kakao.com/web/sample/keywordBasic/</p>]]></content><author><name>Reyna</name></author><category term="notes" /><category term="kakao map api" /><category term="react" /><category term="typescript" /><summary type="html"><![CDATA[kakao map api]]></summary></entry><entry><title type="html">Redux</title><link href="http://localhost:4000/redux/" rel="alternate" type="text/html" title="Redux" /><published>2023-04-16T00:00:00+09:00</published><updated>2023-04-16T00:00:00+09:00</updated><id>http://localhost:4000/redux</id><content type="html" xml:base="http://localhost:4000/redux/"><![CDATA[<h1 id="redux">Redux</h1>

<p>리덕스는 상태를 관리하기 위해 사용되는 자바스크립트 라이브러리 중에 하나이다.</p>

<p>#</p>]]></content><author><name>Reyna</name></author><summary type="html"><![CDATA[Redux]]></summary></entry><entry><title type="html">[typescript] 타입스크립트의 컴파일 과정</title><link href="http://localhost:4000/typescript/tsc/" rel="alternate" type="text/html" title="[typescript] 타입스크립트의 컴파일 과정" /><published>2023-04-16T00:00:00+09:00</published><updated>2023-04-16T00:00:00+09:00</updated><id>http://localhost:4000/typescript/tsc</id><content type="html" xml:base="http://localhost:4000/typescript/tsc/"><![CDATA[<h2 id="타입스크립트의-컴파일-과정">타입스크립트의 컴파일 과정</h2>

<ol>
  <li>타입스크립트 코드를 TS AST(추상 문법 트리)로 변환한다.</li>
  <li>TS AST를 타입 검사기가 확인한다(이때 타입 에러를 발생시킨다)</li>
  <li>확인 후 JS 소스로 변환</li>
</ol>

<p>→ 여기까지의 과정을 TSC가 수행한다</p>

<ol>
  <li>JS 코드를 JS AST로 변환</li>
  <li>AST를 바이트 코드로 바꾼다</li>
  <li>바이트 코드를 런타임이 평가해서 결과를 내보낸다</li>
</ol>

<p>→ 이 과정을 V8 같은 엔진이 수행한다. (4,5 번까지는 JS 컴파일러가, 6번은 런타임이 실행한다)</p>

<p class="notice--primary">AST <br />
컴파일러가 소스 코드를 파싱하여 컴퓨터가 이해하기 쉽도록 문법 구조로 나타낸 트리. 공백이나 주석, 탭 등을 무시한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

<span class="c1">//AST</span>
<span class="o">-</span> <span class="nx">VariableDeclaration</span>
    <span class="o">-</span> <span class="nx">Identifier</span> <span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">result</span><span class="dl">"</span><span class="p">)</span>
    <span class="o">-</span> <span class="nx">CallExpression</span>
      <span class="o">-</span> <span class="nx">Identifier</span> <span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">add</span><span class="dl">"</span><span class="p">)</span>
      <span class="o">-</span> <span class="nx">NumericLiteral</span> <span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
      <span class="o">-</span> <span class="nx">NumericLiteral</span> <span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Reyna</name></author><category term="typescript" /><category term="typescript" /><category term="compile" /><summary type="html"><![CDATA[typescript]]></summary></entry><entry><title type="html">Tailwind CSS 알아보기</title><link href="http://localhost:4000/css/tailwind/" rel="alternate" type="text/html" title="Tailwind CSS 알아보기" /><published>2023-04-14T00:00:00+09:00</published><updated>2023-04-14T00:00:00+09:00</updated><id>http://localhost:4000/css/tailwind</id><content type="html" xml:base="http://localhost:4000/css/tailwind/"><![CDATA[<h1 id="tailwind-css">Tailwind CSS</h1>

<p>Tailwind CSS는 유틸리티 최우선(utility first)을 모토로 만든 CSS 프레임워크이다. Tailwind는 이미 정의되어 있는 클래스를 제공하기 때문에 css를 빠르게 적용하여 시간을 단축할 수 있고, 디자인에 일관성이 있고 유지보수하기 쉽다는 장점을 가진다.</p>

<h1 id="설치">설치</h1>

<p>Tailwind CSS는 PostCSS의 플러그인 형태로 동작한다. 따라서 함께 설치해주어야 한다. 그리고 벤더 접두사 문제를 해결해주는 autoprefixer도 PostCSS의 플러그인으로, 함께 설치해주면 좋다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npm</span> <span class="nx">install</span> <span class="o">-</span><span class="nx">D</span> <span class="nx">tailwindcss</span> <span class="nx">postcss</span> <span class="nx">autoprefixer</span>
</code></pre></div></div>

<p class="notice--primary">PostCSS는 CSS 전처리기로, 여러가지 플러그인들을 활용해서 CSS를 처리하고 변환하는 데 사용된다. Tailwind CSS, Autoprefixer도 Tailwind의 플러그인으로, PostCSS 설정 파일에 추가해서 사용할 수 있다.</p>

<h1 id="구성-파일-만들기">구성 파일 만들기</h1>

<p>Tailwind CSS를 사용하기 위해서는 두 개의 구성 파일이 필요하다.</p>]]></content><author><name>Reyna</name></author><category term="css" /><category term="css" /><category term="tailwind" /><category term="postcss" /><category term="autofixer" /><summary type="html"><![CDATA[tailwind css]]></summary></entry><entry><title type="html">[한입 크기로 잘라 먹는 리액트] 간단한 일기장 만들기</title><link href="http://localhost:4000/lecture/simple-diary/" rel="alternate" type="text/html" title="[한입 크기로 잘라 먹는 리액트] 간단한 일기장 만들기" /><published>2023-04-14T00:00:00+09:00</published><updated>2023-04-15T00:00:00+09:00</updated><id>http://localhost:4000/lecture/simple-diary</id><content type="html" xml:base="http://localhost:4000/lecture/simple-diary/"><![CDATA[<p><img src="https://user-images.githubusercontent.com/110877564/232182349-7039b316-9092-4f39-b2aa-752e54e9aeb7.png" alt="제목을-입력해주세요_-004" /></p>

<p>섹션 6에서는 간단한 일기장을 만들어보았다.</p>

<p><br /></p>

<p><img width="1520" alt="스크린샷 2023-04-14 오후 7 48 00" src="https://user-images.githubusercontent.com/110877564/232024604-e33e6bae-0ede-4d64-92be-23dca9f8a2c6.png" /></p>

<p>일기장은 총 세 영역으로 나누어진다. 첫 번째가 일기를 작성할 수 있는 에디터 영역, 두 번째는 일기의 메타 정보를 보여주는 영역, 마지막이 일기를 보여주는 리스트 영역이다.</p>

<p><br /></p>

<h1 id="diary-editor-컴포넌트">Diary Editor 컴포넌트</h1>

<p><img width="556" alt="스크린샷 2023-04-14 오후 7 56 15" src="https://user-images.githubusercontent.com/110877564/232026257-c937b3c4-5d34-4168-8008-ab8fd6a96b7a.png" /></p>

<h2 id="여러가지-상태를-한번에-관리하기">여러가지 상태를 한번에 관리하기</h2>

<p>다이어리 에디터는 작성자, 일기 본문, 감정 점수 세 개의 입력값을 필요로 한다. 각각 <code class="language-plaintext highlighter-rouge">input</code>, <code class="language-plaintext highlighter-rouge">textarea</code>, <code class="language-plaintext highlighter-rouge">select &amp; option</code> 태그를 이용하는데, 이 입력값은 하나의 상태로 관리할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">state</span><span class="p">,</span> <span class="nx">setState</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">({</span>
  <span class="na">author</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span>
  <span class="na">content</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span>
  <span class="na">emotion</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span>
<span class="p">})</span>

<span class="kd">const</span> <span class="nx">handleChangeState</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setState</span><span class="p">({</span>
    <span class="p">...</span><span class="nx">state</span><span class="p">,</span> <span class="c1">//spread 연산자</span>
    <span class="p">[</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">]:</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="c1">//해당 값만 바꿔준다</span>
  <span class="p">})</span>
<span class="p">}</span>

 <span class="k">return</span><span class="p">(</span>
  <span class="p">...</span>
  <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">name</span><span class="o">=</span><span class="dl">"</span><span class="s2">author</span><span class="dl">"</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">state</span><span class="p">.</span><span class="nx">author</span><span class="p">}</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">handleChangeState</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>  <span class="c1">//textare와 select 태그도 같은 방식으로 만들어준다.</span>
  <span class="p">...</span>
 <span class="p">)</span>
</code></pre></div></div>

<h2 id="useref를-이용하여-원하는-요소에-포커싱-하기">useRef를 이용하여 원하는 요소에 포커싱 하기</h2>

<p>일기 저장 버튼을 눌렀을 때, 저자 혹은 일기의 내용이 원하는 값 이상으로 입력되지 않았을 때 useRef를 이용하여 포커싱을 할 수 있다. useRef()는 DOM 요소를 조작할 수 있는 리액트 훅으로 ref는 레퍼런스, 즉 참조를 의미한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">authorInput</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">()</span>
</code></pre></div></div>

<p>먼저 useRef를 호출한 뒤에 그 반환값을 상수에 담아주었다. 이 상수에는 <code class="language-plaintext highlighter-rouge">React.MutableRefObject</code>가 담기게 되는데, <code class="language-plaintext highlighter-rouge">MutableRefObject</code>는 DOM 요소를 저장하고 관리할 수 있는 기능을 가지고 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">input</span>
  <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">authorInput</span><span class="p">}</span>
  <span class="nx">name</span><span class="o">=</span><span class="dl">"</span><span class="s2">author</span><span class="dl">"</span>
  <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">state</span><span class="p">.</span><span class="nx">author</span><span class="p">}</span>
  <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">handleChangeState</span><span class="p">}</span>
<span class="sr">/</span><span class="err">&gt;
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">input</code>에 <code class="language-plaintext highlighter-rouge">ref</code> 속성을 통해 <code class="language-plaintext highlighter-rouge">authorInput</code>를 할당해준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">author</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">authorInput</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">focus</span><span class="p">()</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="c1">//조건을 만족했을 경우 제출</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">authorInput</code>가 는 현재 가리키고 있는 <code class="language-plaintext highlighter-rouge">input</code> 요소를 <code class="language-plaintext highlighter-rouge">current</code> 속성을 통해 조작할 수 있다. (<code class="language-plaintext highlighter-rouge">current</code> 속성은 <code class="language-plaintext highlighter-rouge">MutableRefObject</code>의 속성 중 하나로, 현재 참조하고 있는 DOM 요소를 가리키는 역할을 한다.)</p>

<p><br /></p>

<h1 id="diary-list--diary-item-컴포넌트">Diary List &amp; Diary Item 컴포넌트</h1>

<p><img width="1086" alt="스크린샷 2023-04-14 오후 8 41 07" src="https://user-images.githubusercontent.com/110877564/232034365-93ab6816-3ab6-4500-97f8-6026e10a3487.png" /></p>

<h2 id="배열을-이용하여-리스트-렌더링하기">배열을 이용하여 리스트 렌더링하기</h2>

<p>다이어리 리스트에서 각각의 일기는 내용만 다르고 구조는 똑같이 생겼다. 만약 일기를 모두 HTML 요소로 나열한다면 중복되는 코드가 계속 늘어날 것이다. 하지만 다이어리 아이템이라는 컴포넌트를 하나 만들어서 반복문을 돌려주면 하나의 컴포넌트로 수많은 일기들을 나타낼 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">diaryList</span> <span class="o">=</span> <span class="cm">/* 일기 데이터 */</span>
</code></pre></div></div>

<p>먼저 다이어리 리스트를 불러온다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
  <span class="p">{</span><span class="nx">diaryList</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">diary</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">DiaryItem</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">diary</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span> <span class="p">{...</span><span class="nx">diary</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">))}</span>
<span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div></div>

<p>map 함수를 이용하여 일기 정보를 하나씩 전달하고, 그 정보를 이용하여 만들어진 <code class="language-plaintext highlighter-rouge">&lt;DiaryItem&gt;</code>가 일기 리스트의 개수만큼 반복되며 반환된다. 그러면 각각의 다이어리가 담긴 배열이 완성되어 렌더링되는 것이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">DiaryItem</span> <span class="o">=</span> <span class="p">({</span><span class="nx">author</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">created_date</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">,</span> <span class="nx">id</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;DiaryList&gt;</code>에서 내려준 <code class="language-plaintext highlighter-rouge">...diary</code>는 이렇게 props로 받아와서 사용하면 된다.</p>

<h2 id="state-끌어올리기">state 끌어올리기</h2>

<p><img width="1174" alt="스크린샷 2023-04-14 오후 9 04 31" src="https://user-images.githubusercontent.com/110877564/232038763-85afaebe-1098-4410-8b04-b21d0fd97909.png" /></p>

<p>리액트에서 데이터는 위에서 아래로 흐른다. 위의 그림처럼 상위 컴포넌트인 App에서 데이터를 관리하고, 다이어리 에디터나 리스트는 그 데이터를 내려받아서 사용한다.
그런데 이 데이터를 바꾸는 일은 하위 컴포넌트에서 발생한다. 여기서는 다이어리 에디터에서 일기를 추가하고 있는데, 이는 이벤트가 밑에서 위로 올라감을 의미한다. 이때 <code class="language-plaintext highlighter-rouge">setData</code> 처럼 상위 컴포넌트에서 상태를 변경하는 함수 자체를 하위 컴포넌트로 전달하고, 이 함수를 하위 컴포넌트에서 실행하여 상태가 변하는 것을 상태 끌어올리기라고 한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//App.js</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">setData</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">([])</span>

<span class="kd">const</span> <span class="nx">onCreate</span> <span class="o">=</span> <span class="p">(</span><span class="nx">author</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">newItem</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">author</span><span class="p">,</span>
    <span class="nx">content</span><span class="p">,</span>
    <span class="nx">emotion</span><span class="p">,</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="nx">setData</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">[</span><span class="nx">newItem</span><span class="p">,...</span><span class="nx">data</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런 식으로 상위 컴포넌트인 App 컴포넌트에 데이터를 두고, 상태를 변경할 수 있는 함수인 <code class="language-plaintext highlighter-rouge">onCreate()</code>를 하위 컴포넌트에 props로 내려준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//App.js</span>
<span class="o">&lt;</span><span class="nx">DiaryEditor</span> <span class="nx">onCreate</span><span class="o">=</span><span class="p">{</span><span class="nx">onCreate</span><span class="p">}</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;DiaryEditor&gt;</code>에서는 함수를 내려받아서 사용하면, 상위 컴포넌트의 상태를 바꿀 수 있게 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//DiaryEditor.js</span>

<span class="kd">const</span> <span class="nx">DiaryEditor</span> <span class="o">=</span> <span class="p">({</span><span class="nx">onCreate</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">//글자수 조건 만족 시 onCreate 함수 실행</span>
    <span class="nx">onCreate</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">author</span><span class="p">,</span> <span class="nx">state</span><span class="p">.</span><span class="nx">content</span><span class="p">,</span> <span class="nx">state</span><span class="p">.</span><span class="nx">emotion</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 data에 일기가 추가되면, 다시 그 데이터를 받아 다이어리 리스트에 반영이 되게 된다.</p>

<p><br /></p>

<h1 id="리액트의-라이프-사이클-제어하기">리액트의 라이프 사이클 제어하기</h1>

<p><img width="1274" alt="스크린샷 2023-04-14 오후 9 35 10" src="https://user-images.githubusercontent.com/110877564/232044918-77eb82cb-bbef-48cc-94ea-738aa235d4b7.png" /></p>

<p>리액트는 탄생, 변화, 죽음이라는 세 개의 생애 주기를 가진다. 함수형 컴포넌트에서 생애 주기를 제어하기 위해서는 useEffect 훅을 사용하면 된다.</p>

<p>useEffect는 두 개의 인자를 받는다.</p>

<p>첫 번째는 실행하게 될 콜백 함수이며, 두 번째는 의존성 배열이라는 것이다. 의존성 배열은 콜백 함수가 실행되는 조건을 제어할 수 있다. 즉 이 배열에 넣어둔 값이 변화하면 콜백 함수가 다시 실행된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Mount!</span><span class="dl">"</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">//언마운트 시점에 실행</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Unmount!</span><span class="dl">"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="p">[])</span> <span class="c1">// 빈 배열을 넣으면 컴포넌트가 마운트 될 때 한 번만 실행</span>

<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">count가 5를 넘었습니다 따라서 1로 초기화합니다</span><span class="dl">"</span><span class="p">)</span>
    <span class="nx">setCount</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">count</span><span class="p">])</span> <span class="c1">//count 값이 변할 때마다 실행</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="리액트에서-api-호출해서-일기의-초기값-만들어주기">리액트에서 API 호출해서 일기의 초기값 만들어주기</h1>

<p><code class="language-plaintext highlighter-rouge">jsonplaceholder</code>는 더미 데이터를 api 호출로 얻을 수 있는 서비스이다.</p>

<p class="notice--primary"><a href="https://jsonplaceholder.typicode.com/">jsonplaceholder</a></p>

<p><code class="language-plaintext highlighter-rouge">fetch()</code>라는 내장 함수를 이용하면 인자로 전달한 url로 요청을 보낼 수 있다. 응답으로 받은 결과를 <code class="language-plaintext highlighter-rouge">res</code>에 담는 함수를 만들어준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getData</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://jsonplaceholder.typicode.com/comments</span><span class="dl">"</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">useEffect()</code>를 이용하면 App 컴포넌트가 마운트 될 때 <code class="language-plaintext highlighter-rouge">getData()</code>를 호출해서 요청을 보낼 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">getData</span><span class="p">()</span>
<span class="p">},</span> <span class="p">[])</span>
</code></pre></div></div>

<p>이 결과를 일기 데이터의 기초 데이터로 사용하기 위해 필요한 정보로 가공해준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">initData</span> <span class="o">=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">it</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">author</span><span class="p">:</span> <span class="nx">it</span><span class="p">.</span><span class="nx">email</span><span class="p">,</span>
    <span class="na">content</span><span class="p">:</span> <span class="nx">it</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span>
    <span class="na">emotion</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">//1~5 랜덤 난수 생성</span>
    <span class="na">created_date</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">(),</span>
    <span class="na">id</span><span class="p">:</span> <span class="nx">dataId</span><span class="p">.</span><span class="nx">current</span><span class="o">++</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<p>가공한 정보를 <code class="language-plaintext highlighter-rouge">setData</code>를 이용하여 data에 담아주면 App 컴포넌트가 마운트될 때 초기값으로 불러온 데이터가 들어가게 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setData</span><span class="p">(</span><span class="nx">initData</span><span class="p">)</span>
</code></pre></div></div>

<p>이 코드들을 합쳐주면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//App.js</span>
<span class="kd">const</span> <span class="nx">getData</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://jsonplaceholder.typicode.com/comments</span><span class="dl">"</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
  <span class="p">)</span>

  <span class="kd">const</span> <span class="nx">initData</span> <span class="o">=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">it</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">author</span><span class="p">:</span> <span class="nx">it</span><span class="p">.</span><span class="nx">email</span><span class="p">,</span>
      <span class="na">content</span><span class="p">:</span> <span class="nx">it</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span>
      <span class="na">emotion</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">//1~5 랜덤 난수 생성</span>
      <span class="na">created_date</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">(),</span>
      <span class="na">id</span><span class="p">:</span> <span class="nx">dataId</span><span class="p">.</span><span class="nx">current</span><span class="o">++</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">})</span>

  <span class="nx">setData</span><span class="p">(</span><span class="nx">initData</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="최적화">최적화</h1>

<h2 id="usememo를-이용해서-연산-결과-재사용하기">useMemo를 이용해서 연산 결과 재사용하기</h2>

<p><img width="1020" alt="스크린샷 2023-04-15 오전 5 42 38" src="https://user-images.githubusercontent.com/110877564/232150924-b7bf9af4-fbc9-4a6d-9fdf-a7ed26f494cd.png" /></p>

<p>메모이제이션을 이용하면 복잡한 연산을 다시 하지 않아도 된다는 장점이 있다.</p>

<p>리액트에서는 useMemo를 통해 메모이제이션을 활용할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//App.js</span>

<span class="cm">/* 감정 점수를 분석하는 함수 */</span>
<span class="kd">const</span> <span class="nx">getDiaryAnalysis</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">goodCount</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">it</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">emotion</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">).</span><span class="nx">length</span>
  <span class="kd">const</span> <span class="nx">badCount</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">goodCount</span>
  <span class="kd">const</span> <span class="nx">goodRatio</span> <span class="o">=</span> <span class="p">(</span><span class="nx">goodCount</span> <span class="o">/</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">goodCount</span><span class="p">,</span> <span class="nx">badCount</span><span class="p">,</span> <span class="nx">goodRatio</span><span class="p">}</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">]</span>
</code></pre></div></div>

<p><img width="946" alt="스크린샷 2023-04-15 오전 5 57 35" src="https://user-images.githubusercontent.com/110877564/232153319-4e2582cb-9667-493d-a62c-0c9355b71969.png" /></p>

<p>여기서 만든 일기장의 경우 감정 점수를 수정할 수 있는 기능이 없다. 따라서 수정이 가능한 건 내용 뿐이고, 위에서 만든 <code class="language-plaintext highlighter-rouge">getDiaryAnalysis()</code> 함수는 일기가 추가/삭제되는 등 일기 리스트의 길이가 변할 때만 작동하면 된다. 여기서 useMemo를 사용하면 언제 다시 계산할 지 정해줄 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//App.js</span>

<span class="cm">/* 메모이제이션 하고 싶은 함수를 useMemo로 감싸준다. */</span>
<span class="kd">const</span> <span class="nx">getDiaryAnalysis</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">goodCount</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">it</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">emotion</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">).</span><span class="nx">length</span>
  <span class="kd">const</span> <span class="nx">badCount</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">goodCount</span>
  <span class="kd">const</span> <span class="nx">goodRatio</span> <span class="o">=</span> <span class="p">(</span><span class="nx">goodCount</span> <span class="o">/</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">goodCount</span><span class="p">,</span> <span class="nx">badCount</span><span class="p">,</span> <span class="nx">goodRatio</span><span class="p">}</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">])</span>
</code></pre></div></div>

<p>이때 주의해야하는 점은 useMemo로 감싼 함수는 함수가 아니라 값을 리턴받기 때문에, 사용할 때 함수처럼 사용하면 에러가 발생한다. 따라서 값을 사용하는 것처럼 바꿔주어야 한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span><span class="nx">goodCount</span><span class="p">,</span> <span class="nx">badCount</span><span class="p">,</span> <span class="nx">goodRatio</span><span class="p">}</span> <span class="o">=</span> <span class="nx">getDiaryAnalysis</span><span class="p">()</span> <span class="c1">//error</span>

<span class="c1">//useMemo를 사용하였으므로 함수(getDiaryAnalysis())가 아니라 값 getDiaryAnalysis으로 사용한다.</span>
<span class="kd">const</span> <span class="p">{</span><span class="nx">goodCount</span><span class="p">,</span> <span class="nx">badCount</span><span class="p">,</span> <span class="nx">goodRatio</span><span class="p">}</span> <span class="o">=</span> <span class="nx">getDiaryAnalysis</span>
</code></pre></div></div>

<p class="notice--primary">💡 메모이제이션은 오히려 앱의 성능을 저하시킬 수 있기 때문에 남용하면 좋지 않다고 한다.
(<a href="https://velog.io/@lky5697/stop-using-usememo-now?utm_source=substack&amp;utm_medium=email">참고</a>)</p>

<h2 id="reactmemo를-이용해서-컴포넌트-재사용하기">React.memo를 이용해서 컴포넌트 재사용하기</h2>

<p>리액트에서 부모 컴포넌트가 리렌더링 되면, 자식 컴포넌트도 리렌더링 된다. 따라서 형제 컴포넌트에 어떤 일이 발생해서 부모 컴포넌트의 상태가 바뀌는 경우, 다른 형제의 컴포넌트는 그 상태를 사용하지 않아 리렌더링 될 필요가 없음에도 불구하고 리렌더되는 현상이 발생한다. 이때 React.memo를 이용하여 컴포넌트에 업데이트 조건을 걸어서 조건을 만족할 때만 리렌더링 되도록 할 수 있다.</p>

<p><a href="https://ko.reactjs.org/docs/react-api.html#reactmemo">공식 문서</a>에 따르면, React.memo는 고차 컴포넌트(HOC)이다. 고차 컴포넌트는 컴포넌트를 가져와 새 컴포넌트를 반환하는 함수이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">좋아진컴포넌트</span> <span class="o">=</span> <span class="nx">고차함수</span><span class="p">(</span><span class="nx">컴포넌트</span><span class="p">)</span>
</code></pre></div></div>

<p>React.memo도 이렇게 매개변수로 컴포넌트를 전달하면, 전달 받은 props가 동일한 결과를 나타낸다면 다시 계산하지 않고 리렌더링도 일어나지 않도록 할 수 있다.</p>

<h3 id="예시-1">예시 1</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">TextView</span> <span class="o">=</span> <span class="p">({</span><span class="nx">text</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Update :: Text : </span><span class="p">${</span><span class="nx">text</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">}</span>

<span class="kd">const</span> <span class="nx">CountView</span> <span class="o">=</span> <span class="p">({</span><span class="nx">count</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Update :: Count : </span><span class="p">${</span><span class="nx">count</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">}</span>
</code></pre></div></div>

<p>렌더링 될 때마다 console에 표시가 되는 컴포넌트를 만들었다. 이 컴포넌트들을 상위 컴포넌트에서 불러서 사용을 해보자.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">text</span><span class="p">,</span> <span class="nx">setText</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="dl">""</span><span class="p">)</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">App</span><span class="dl">"</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">count</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">CountView</span> <span class="nx">count</span><span class="o">=</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span><span class="o">&gt;</span>
          <span class="o">+</span>
        <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">text</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">TextView</span> <span class="nx">text</span><span class="o">=</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">setText</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">)}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>App 컴포넌트에서 버튼을 클릭하면 text는 상태가 그대로인데도 <code class="language-plaintext highlighter-rouge">&lt;TextView&gt;</code> 컴포넌트가 다시 렌더링되면서 console이 찍히는 것을 확인할 수 있다. 또 text를 바꾸었을 때도 count는 2인데 계속 렌더링되고 있다.</p>

<p><img width="256" alt="스크린샷 2023-04-15 오전 9 45 40" src="https://user-images.githubusercontent.com/110877564/232174748-a95ca3fe-913f-4434-ab8f-0d392545ab07.png" /></p>

<p>이제 이 컴포넌트들을 React.memo로 감싸보자.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">TextView</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(({</span><span class="nx">text</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Update :: Text : </span><span class="p">${</span><span class="nx">text</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">})</span>

<span class="kd">const</span> <span class="nx">CountView</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(({</span><span class="nx">count</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Update :: Count : </span><span class="p">${</span><span class="nx">count</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">})</span>
</code></pre></div></div>

<p>이렇게 바꿔주면 각자 인자로 들어온 값이 바뀌지 않으면 재계산하지 않게 된다.</p>

<p><img width="258" alt="스크린샷 2023-04-15 오전 9 48 49" src="https://user-images.githubusercontent.com/110877564/232174872-ab13f181-d7a1-4ba3-903d-3c9221e500bb.png" /></p>

<h3 id="예시-2">예시 2</h3>

<p>다른 예도 살펴보자.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">CounterA</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(({</span><span class="nx">count</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`CounterA Update - count : </span><span class="p">${</span><span class="nx">count</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">})</span>

<span class="kd">const</span> <span class="nx">CounterB</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(({</span><span class="nx">obj</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`CounterB Update - count : </span><span class="p">${</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">})</span>

<span class="kd">const</span> <span class="nx">OptimizeTest</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">setObj</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">({</span>
    <span class="na">count</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">style</span><span class="o">=&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">Counter</span> <span class="nx">A</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">CounterA</span> <span class="nx">count</span><span class="o">=</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&gt;&lt;</span><span class="sr">/CounterA</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">A</span> <span class="nx">BUTTON</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">Counter</span> <span class="nx">B</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">CounterB</span> <span class="nx">obj</span><span class="o">=</span><span class="p">{</span><span class="nx">obj</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setObj</span><span class="p">({</span><span class="na">count</span><span class="p">:</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">})}</span><span class="o">&gt;</span><span class="nx">B</span> <span class="nx">BUTTON</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">OptimizeTest</span>
</code></pre></div></div>

<p>아까처럼 두 개의 컴포넌트를 만들고 React.memo로 감싼 뒤 상위 컴포넌트에서 불러와서 사용해보았다. 다른 점은 버튼을 클릭해도 같은 결과를 리턴하고, Counter B 같은 경우 객체 형태라는 것이다.
버튼을 클릭했을 때, Counter A는 예상대로 동작한다. 즉 count가 바뀌지 않기 때문에 리렌더링 되지 않고, 콘솔 창에 아무것도 나타나지 않는다. 하지만 B 버튼을 누르면 obj의 count가 바뀌지 않음에도 리렌더링 된다. 이건 객체를 비교할 때, 얕은 비교를 하기 때문이다.</p>

<p>얕은 비교는 객체를 값이 아니라 주소를 기준으로 비교하는 것이다.</p>

<p><img width="1314" alt="스크린샷 2023-04-15 오전 10 27 15" src="https://user-images.githubusercontent.com/110877564/232176589-7335d630-0fe0-4f27-b574-0dc143ac2ac3.png" /></p>

<p>위의 그림처럼 a 객체와 b 객체는 선언될 때 다른 주소에 저장된다. 따라서 값은 같더라도, 주소가 다르기 때문에 비교했을 때 false가 나온다.</p>

<p><img width="1314" alt="스크린샷 2023-04-15 오전 10 30 53" src="https://user-images.githubusercontent.com/110877564/232176735-70f3c216-294d-4e79-b30b-4bee71afceaf.png" /></p>

<p>한편 a를 선언한 후에 b에 직접 할당할 경우, 둘은 같은 주소를 가지게 된다. 따라서 비교했을 때 true가 나온다.</p>

<p>여기서 B 버튼을 클릭했을 때, <code class="language-plaintext highlighter-rouge">setObj({count: obj.count})</code>가 실행되면서 새로운 객체 <code class="language-plaintext highlighter-rouge">{count: obj.count}</code>가 생성되어 obj가 변경되고, 이전 상태의 obj와 새로운 obj는 얕은 비교를 수행해서 값은 다르지만 주소가 다르기 때문에 다르다고 판단되어 <code class="language-plaintext highlighter-rouge">&lt;CounterB&gt;</code> 컴포넌트가 다시 렌더링된다.</p>

<p>이런 현상을 방지하기 위해 React.memo에 두 번째 인자로, <code class="language-plaintext highlighter-rouge">areEqual()</code>이라는 함수를 사용할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//React.memo를 없애주었다</span>
<span class="kd">const</span> <span class="nx">CounterB</span> <span class="o">=</span> <span class="p">({</span><span class="nx">obj</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`CounterB Update - count : </span><span class="p">${</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">}</span>

<span class="kd">const</span> <span class="nx">areEqual</span> <span class="o">=</span> <span class="p">(</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">prev</span><span class="p">.</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span> <span class="o">===</span> <span class="nx">next</span><span class="p">.</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span> <span class="c1">//이전 props 현재 props가 같으면 리렌더링 하지 않음</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">MemoisedCouanterB</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(</span><span class="nx">CounterB</span><span class="p">,</span> <span class="nx">areEqual</span><span class="p">)</span> <span class="c1">//컴포넌트를 반환하는 고차 컴포넌트</span>

<span class="c1">//return</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">Counter</span> <span class="nx">B</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">MemoisedCouanterB</span> <span class="nx">obj</span><span class="o">=</span><span class="p">{</span><span class="nx">obj</span><span class="p">}</span><span class="o">&gt;&lt;</span><span class="sr">/MemoisedCouanterB</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setObj</span><span class="p">({</span><span class="na">count</span><span class="p">:</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">})}</span><span class="o">&gt;</span><span class="nx">B</span> <span class="nx">BUTTON</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">areEqual()</code> 함수를 적용해보았다. 이렇게 바꿔줄 경우, 먼저 <code class="language-plaintext highlighter-rouge">areEqual()</code> 함수에서 obj가 아니라 obj.count를 비교한다. 객체가 아니라 값을 비교하기 때문에 값이 같다면 true가 나오고, 아니라면 false가 나오게 된다. 그리고 React.memo의 두 번째 인자가 false가 되는 경우에만 다시 리렌더링을 수행하게 되기 때문에, 얕은 비교를 막고 실제로 값이 변경되었을 때에만 리렌더링이 일어나게 된다.</p>

<h2 id="usecallback으로-함수-최적화하기">useCallback으로 함수 최적화하기</h2>

<p>useMemo는 메모이제이션된 값을 반환한다. 만약 함수를 반환하고 싶을 때에는 useCallback을 사용하면 된다.</p>

<p>다이어리를 작성하는 폼인 <code class="language-plaintext highlighter-rouge">&lt;DiaryEditor&gt;</code> 컴포넌트는 App 컴포넌트에서 props로 <code class="language-plaintext highlighter-rouge">onCreate()</code> 함수를 내려받는다. 만약 다이어리가 수정되거나 삭제될 경우 App 컴포넌트에서 다이어리의 상태가 바뀌면서 <code class="language-plaintext highlighter-rouge">onCreate()</code> 함수도 재생성되고, 또 이 함수를 내려받는 <code class="language-plaintext highlighter-rouge">&lt;DiaryEditor&gt;</code> 컴포넌트도 리렌더링되게 된다. 일기 추가와만 관련이 있는데도 불구하고 불필요하게 렌더링되고 있는 것이다. 이럴 때 <code class="language-plaintext highlighter-rouge">onCreate()</code> 함수에 useCallback을 적용하면 좋다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">onCreate</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">((</span><span class="nx">author</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">newItem</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">author</span><span class="p">,</span>
    <span class="nx">content</span><span class="p">,</span>
    <span class="nx">emotion</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="nx">setData</span><span class="p">([</span><span class="nx">newItem</span><span class="p">,</span> <span class="p">...</span><span class="nx">data</span><span class="p">])</span> <span class="c1">//이렇게하면 data가 새로운 배열로 덮어씌워지기 때문에 새로운 데이터만 남게 된다.</span>
  <span class="nx">setData</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">newItem</span><span class="p">,</span> <span class="p">...</span><span class="nx">data</span><span class="p">])</span> <span class="c1">//이렇게 함수형 업데이트를 해줘야 이전 상태값을 받아와서 의도에 맞는 업데이트가 가능하다.</span>
<span class="p">},</span> <span class="p">[])</span>
</code></pre></div></div>

<p>이렇게 감싸주면 다른 함수로 인해 data가 업데이트 되어도 <code class="language-plaintext highlighter-rouge">onCreate()</code>는 달라진 부분이 없으면 다시 생성되지 않아 <code class="language-plaintext highlighter-rouge">&lt;DiaryEditor&gt;</code>가 불필요하게 리렌더링되는 것을 방지할 수 있다.</p>

<p><br /></p>

<h1 id="usereducer를-이용하여-복잡한-상태-분리하기">useReducer를 이용하여 복잡한 상태 분리하기</h1>

<p>useReducer를 이용하면 상태 관리 로직을 컴포넌트 밖으로 빼내서 컴포넌트의 복잡도를 줄일 수 있다. useReducer는 상태변화를 처리해주는 reducer와 state의 초기값으로 두 개의 인자를 받아 state와 dispatch 함수로 이루어진 배열을 반환한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">dispatch</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useReducer</span><span class="p">(</span><span class="nx">reducer</span><span class="p">,</span> <span class="p">[])</span>
</code></pre></div></div>

<p>먼저 dispatch로 상태 변화를 일으키고, reducer가 상태 변화를 처리해서 data가 변경되는 구조를 가진다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">onCreate</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">((</span><span class="nx">author</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">dispatch</span><span class="p">({</span>
    <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">CREATE</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">data</span><span class="p">:</span> <span class="p">{</span><span class="nx">author</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">,</span> <span class="na">id</span><span class="p">:</span> <span class="nx">dataId</span><span class="p">.</span><span class="nx">current</span><span class="p">},</span>
  <span class="p">})</span>

  <span class="nx">dataId</span><span class="p">.</span><span class="nx">current</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">},</span> <span class="p">[])</span>
</code></pre></div></div>

<p>dispatch는 이런 식으로 호출하면서 객체를 전달하는데, 이 객체 이름을 action 객체라고 부른다. action 객체를 reducer로 전달하면 reducer에서 상태를 변경해준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">reducer</span> <span class="o">=</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">CREATE</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">created_date</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">()</span>
      <span class="kd">const</span> <span class="nx">newItem</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">...</span><span class="nx">action</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span>
        <span class="nx">created_date</span><span class="p">,</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">[</span><span class="nx">newItem</span><span class="p">,</span> <span class="p">...</span><span class="nx">state</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="c1">//case 별로 구현</span>

    <span class="nl">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>dispatch에서는 첫번째 인자로 원래 상태를, 두 번째 인자로 dispatch가 전달해준 action 객체를 받는다.
그리고 action의 타입에 따라 state를 변경해준 뒤, 바뀐 state를 반환한다. 즉 상태가 변경된다.</p>

<p><br /></p>

<h1 id="context로-컴포넌트-트리에-전역으로-데이터-공급하기">context로 컴포넌트 트리에 전역으로 데이터 공급하기</h1>

<p>리액트는 단방향 데이터 흐름을 가지기 때문에, 데이터를 위에서 아래로 props로 전해준다. 하지만 컴포넌트가 여러 단계에 걸쳐 연결되어 있을 경우, 제일 아래에 있는 컴포넌트에서만 필요한 데이터를 전달해주려면 최상위 컴포넌트에서 그 아래로, 또 그 아래로 계속 props를 내려주게 된다. 이때 중간에 있는 컴포넌트들은 데이터를 사용하지도 않으면서 오로지 props를 전달하는 역할을 하게 된다. 이를 props 드릴링이라고 하는데, 이런 드릴링이 생길 경우 데이터를 관리하기가 매우 복잡해진다.</p>

<p>이런 문제를 해결하기 위해 context라는 개념이 생겨났다.</p>

<p><img width="1314" alt="스크린샷 2023-04-15 오후 12 55 32" src="https://user-images.githubusercontent.com/110877564/232181738-9ea2fc17-dbdf-48ec-8b1b-6ac8ec1f9337.png" />
이 그림처럼 provider라는 컴포넌트는 App 컴포넌트에서 모든 데이터를 받아서 필요한 컴포넌트에 바로 데이터를 줄 수 있다. 따라서 불필요한 데이터 드릴링이 일어나지 않게 된다.</p>

<p>이때 provider가 포함하고 있는 범위를 context, 문맥이라고 하며 이 context 안에서는 어떤 컴포넌트든 데이터를 받아와서 사용할 수 있다.</p>

<p>리액트는 <code class="language-plaintext highlighter-rouge">context API</code>를 제공하여 이런 기능을 사용할 수 있게 만들어준다.</p>

<h2 id="context-생성">context 생성</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">DiaryStateContext</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createContext</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="context-provier를-이용해서-데이터-공급하기">Context Provier를 이용해서 데이터 공급하기</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//App.js</span>
  <span class="o">&lt;</span><span class="nx">DiaryStateContext</span><span class="p">.</span><span class="nx">Provider</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">data</span> <span class="p">{</span><span class="cm">/*전역으로 공급할 값*/</span><span class="p">}}</span><span class="o">&gt;</span>
    <span class="p">{</span><span class="cm">/*context 안에 위치하는 자식 컴포넌트들*/</span><span class="p">}</span>
  <span class="o">&lt;</span><span class="sr">/DiaryStateContext.Provider</span><span class="err">&gt;
</span></code></pre></div></div>

<h2 id="하위-컴포넌트에서-데이터를-가져와서-사용하기">하위 컴포넌트에서 데이터를 가져와서 사용하기</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//DiaryList.jsx</span>
<span class="kd">const</span> <span class="nx">diaryList</span> <span class="o">=</span> <span class="nx">useContext</span><span class="p">(</span><span class="nx">DiaryStateContext</span><span class="p">)</span> <span class="c1">//data가 할당된다.</span>
</code></pre></div></div>

<h2 id="context-중첩해서-사용하기">context 중첩해서 사용하기</h2>

<p>데이터 뿐만 아니라 상태를 변경하는 dispatch 함수도 전역으로 내려주고 싶으면 어떻게 할까? 만약 아까 만들어두었던 <code class="language-plaintext highlighter-rouge">DiaryStateContext</code>를 사용하면 데이터가 변경될 때마다 함수들도 재생성되는 문제가 발생한다. 따라서 다른 문맥을 만들어 중첩해서 사용하는 것이 좋다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//App.js</span>
<span class="kd">const</span> <span class="nx">DiaryDispatchContext</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createContext</span><span class="p">()</span> <span class="c1">//새로운 context 생성</span>

<span class="c1">//전달할 함수를 하나로 만들기</span>
<span class="kd">const</span> <span class="nx">memoizedDispatches</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">onCreate</span><span class="p">,</span> <span class="nx">onRemove</span><span class="p">,</span> <span class="nx">onEdit</span><span class="p">}</span>
<span class="p">},</span> <span class="p">[])</span>

<span class="c1">//중첩해서 사용</span>
<span class="k">return</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">DiaryStateContext</span><span class="p">.</span><span class="nx">Provider</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">data</span><span class="p">}</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">DiaryDispatchContext</span><span class="p">.</span><span class="nx">Provider</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">memoizedDispatches</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="cm">/*context 안에 위치하는 자식 컴포넌트들*/</span><span class="p">}</span>
    <span class="o">&lt;</span><span class="sr">/DiaryDispatchContext.Provider</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/DiaryStateContext.Provider</span><span class="err">&gt;
</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DiaryStateContext</code>와 마찬가지로 인자로 원하는 문맥을 넣고 꺼내서 사용하면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//DiaryItem.jsx</span>
<span class="kd">const</span> <span class="p">{</span><span class="nx">onRemove</span><span class="p">,</span> <span class="nx">onEdit</span><span class="p">}</span> <span class="o">=</span> <span class="nx">useContext</span><span class="p">(</span><span class="nx">DiaryDispatchContext</span><span class="p">)</span>
</code></pre></div></div>

<p>간단한 일기장을 만들면서 CRUD 기능, 최적화, 상태 관리까지 전체적으로 알아볼 수 있었던 섹션이었다.</p>]]></content><author><name>Reyna</name></author><category term="lecture" /><category term="udemy" /><category term="react" /><category term="useMemo" /><category term="useCallback" /><category term="useReducer" /><summary type="html"><![CDATA[react]]></summary></entry><entry><title type="html">[Mini Project] 감성 일기장 업그레이드 4. Diary Page 타입스크립트 적용하기</title><link href="http://localhost:4000/mini%20project/emotion-diary-4/" rel="alternate" type="text/html" title="[Mini Project] 감성 일기장 업그레이드 4. Diary Page 타입스크립트 적용하기" /><published>2023-04-13T00:00:00+09:00</published><updated>2023-04-13T00:00:00+09:00</updated><id>http://localhost:4000/mini%20project/emotion-diary-4</id><content type="html" xml:base="http://localhost:4000/mini%20project/emotion-diary-4/"><![CDATA[<p><img src="https://user-images.githubusercontent.com/110877564/232606809-6ff5b383-906f-41b5-9b4c-947de201d254.png" alt="제목을-입력해주세요_-004 (1)" /></p>

<p>감성 일기장은 총 네 종류의 페이지로 이루어져 있다.</p>

<p><img width="1536" alt="스크린샷 2023-04-13 오후 2 45 52" src="https://user-images.githubusercontent.com/110877564/231697730-38f73a20-57f7-4d5f-9d18-ced9596f7c17.png" /></p>

<p>위 그림은 강의에서 처음 프로젝트를 구성할 때 나오는 것으로, 컴포넌트 구조를 나타낸다.
여기서 일기를 생성하는 페이지와 수정하는 페이지는 거의 동일한 구조를 가지고 있고, <code class="language-plaintext highlighter-rouge">DiaryEditor</code> 컴포넌트를 공유한다. 그리고 홈 페이지는 하위에 <code class="language-plaintext highlighter-rouge">DiaryList</code> 그리고 <code class="language-plaintext highlighter-rouge">DiaryList</code> 컴포넌트는 <code class="language-plaintext highlighter-rouge">DiaryItem</code>으로 구성되어 있다.</p>

<p><br /></p>

<h1 id="date-type-문제">date type 문제</h1>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//DiaryItem.tsx</span>
<span class="kr">interface</span> <span class="nx">Props</span> <span class="p">{</span>
  <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span>
  <span class="nx">date</span><span class="p">:</span> <span class="kr">number</span>
  <span class="nx">emotion</span><span class="p">:</span> <span class="kr">number</span>
  <span class="nx">content</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DiaryItem</code>의 타입은 이렇게 설정해주었다. 처음에는 date가 ‘2023.04.13’ 처럼 <code class="language-plaintext highlighter-rouge">string</code> 형식으로 들어가는 줄 알고 그렇게 만들었더니,
<code class="language-plaintext highlighter-rouge">DiaryList</code> 쪽에서 문제가 생겼다. 날짜가 들어가는 컴포넌트들이 여러 곳에 있어서 정확하게 어떻게 넣어주어야 하는지 파악하려고 여러 컴포넌트들을 수정해보면서 찾았다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//DiaryItem.tsx</span>
<span class="c1">// ms로 들어온 날짜를 연월일 형식으로 바꿔줌</span>
<span class="kd">const</span> <span class="nx">strDate</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">date</span><span class="p">).</span><span class="nx">toLocaleDateString</span><span class="p">()</span>
</code></pre></div></div>

<p>그런데 <code class="language-plaintext highlighter-rouge">DiaryItem</code>에서 이런 변수를 발견했다. ‘1681344000000’처럼 ms 형식으로 들어온 날짜를 ‘2023.4.13’ 처럼 바꿔주는 함수였다. 그러니까 일기 아이템으로 들어온 날짜를 보기 편하게 바꿔서 <code class="language-plaintext highlighter-rouge">&lt;div className="diary_date"&gt;{strDate}&lt;/div&gt;</code>에 넣어주는 역할을 하는 것이다. 그래서 다시 date의 type을 <code class="language-plaintext highlighter-rouge">number</code>로 바꿔주었다.</p>

<p><code class="language-plaintext highlighter-rouge">App.tsx</code>에서도 string으로 설정했다가 에러가 발생했는데, 새로운 일기를 쓸 때 <code class="language-plaintext highlighter-rouge">DiaryEditor</code>에서 <code class="language-plaintext highlighter-rouge">App.tsx</code>에 있는 <code class="language-plaintext highlighter-rouge">onCreate()</code> 함수를 호출한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">newDiaryItem</span><span class="p">:</span> <span class="nx">createDiary</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">date</span><span class="p">:</span> <span class="nx">date</span><span class="p">,</span>
  <span class="na">content</span><span class="p">:</span> <span class="nx">content</span><span class="p">,</span>
  <span class="na">emotion</span><span class="p">:</span> <span class="nx">emotion</span><span class="p">,</span>
  <span class="na">id</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">onCreate</span><span class="p">(</span><span class="nx">newDiaryItem</span><span class="p">)</span>
</code></pre></div></div>

<p>여기에서 date는 useState로 관리한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">date</span><span class="p">,</span> <span class="nx">setDate</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="nx">getStringDate</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">()))</span>
</code></pre></div></div>

<p>초기값은 현재 시간을 <code class="language-plaintext highlighter-rouge">getStringDate()</code>라는 함수를 이용하고 있다. 그리고 달력에서 날짜를 클릭하면 바뀌는 식이다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">input</span>
  <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">input_date</span><span class="dl">"</span>
  <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">date</span> <span class="o">||</span> <span class="dl">""</span><span class="p">}</span>
  <span class="nx">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">setDate</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">)}</span>
  <span class="kd">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">date</span><span class="dl">"</span>
<span class="o">/&gt;</span>
</code></pre></div></div>

<p>그리고 <code class="language-plaintext highlighter-rouge">getStringDate()</code>는 날짜를 ‘2023-04-13’ 이런 식으로 바꿔주는 유틸 함수로, 화면에 표시하기 위해 사용되고 있다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">getStringDate</span> <span class="o">=</span> <span class="p">(</span><span class="nx">date</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">date</span><span class="p">.</span><span class="nx">toISOString</span><span class="p">().</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그리고 onCreate 함수에서 dispatch를 이용하여 일기를 만들어준다. 이때 날짜는 다시 ms로 바꿔서 보내주기 때문에, 저장될 때는 number 형식으로 저장되게 된다.
<img width="565" alt="스크린샷 2023-04-17 오후 10 26 28" src="https://user-images.githubusercontent.com/110877564/232498082-cb1b678c-5f23-42f6-ac93-c4ac28697e84.png" />
결과적으로 로컬 스토리지에는 이렇게 저장되고,
<img width="607" alt="스크린샷 2023-04-17 오후 10 26 45" src="https://user-images.githubusercontent.com/110877564/232498094-209fe446-1281-4771-b61c-8e6b5b2c8ad5.png" />
화면 상으로는 이렇게 보인다.</p>

<h1 id="typests">types.ts</h1>

<p>다이어리를 여러 컴포넌트에서 쓰다보니 모든 곳에서 같은 타입을 중복해서 선언하고 있었다. 그래서 타입 파일을 하나 만들어서 import 해서 사용하도록 바꿔주었다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//export</span>
<span class="k">export</span> <span class="kr">interface</span> <span class="nx">DiaryItem</span> <span class="p">{</span>
  <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span>
  <span class="nx">date</span><span class="p">:</span> <span class="kr">number</span>
  <span class="nx">content</span><span class="p">:</span> <span class="kr">string</span>
  <span class="nx">emotion</span><span class="p">:</span> <span class="kr">number</span>
<span class="p">}</span>

<span class="c1">//import</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">DiaryItem</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../types</span><span class="dl">"</span>
</code></pre></div></div>

<p>date 타입을 지정하다보니 결과적으로 diary와 관련된 모든 컴포넌트를 거의 동시에 바꿔줘서 순차적으로 하지는 못했지만 일기 외에 따로 타입을 지정해줘야 하는 부분이 거의 없어서 모든 파일을 타입스크립트로 바꿀 수 있었다.</p>]]></content><author><name>Reyna</name></author><category term="mini project" /><category term="project" /><category term="wanted challenge" /><category term="react" /><category term="typescript" /><summary type="html"><![CDATA[wanted challenge]]></summary></entry><entry><title type="html">[한입 크기로 잘라 먹는 리액트] 리액트 입문 - 스샷 추가 후 올려야함 ㅠ</title><link href="http://localhost:4000/lecture/react/" rel="alternate" type="text/html" title="[한입 크기로 잘라 먹는 리액트] 리액트 입문 - 스샷 추가 후 올려야함 ㅠ" /><published>2023-04-10T00:00:00+09:00</published><updated>2023-04-10T00:00:00+09:00</updated><id>http://localhost:4000/lecture/react</id><content type="html" xml:base="http://localhost:4000/lecture/react/"><![CDATA[<h1 id="왜-리액트를-사용할까">왜 리액트를 사용할까?</h1>

<p><code class="language-plaintext highlighter-rouge">html</code>, <code class="language-plaintext highlighter-rouge">css</code>, <code class="language-plaintext highlighter-rouge">javascript</code>만 이용해도 웹사이트를 만들 수 있다. 그렇다면 리액트를 사용했을 때의 장점이 뭐가 있을까?</p>

<h2 id="컴포넌트-기반-구조">컴포넌트 기반 구조</h2>

<p>리액트는 컴포넌트 기반의 UI 라이브러리이다.
컴포넌트 기반이라는 것은 화면을 각각 컴포넌트 단위로 나누어서 개별적으로 관리할 수 있다는 것을 의미한다.</p>

<p>여기서 컴포넌트는 UI를 구성하는 최소 단위이다. 예를 들어 웹 사이트의 헤더, 푸터, 내비게이션 바 등을 컴포넌트라고 할 수 있다. 이 요소들을 각각 따로 관리하면 화면을 바꾸거나 다르게 조합하고 싶을 때 필요한 요소만 사용이 가능하고, 재사용하기도 쉽다. 만약 내용이 거의 동일한 페이지가 있다면, 다른 요소는 재사용하고 바뀌는 일부분만 교체해주면 될 것이다. 또 여러 곳에서 재사용하는 컴포넌트를 바꾼다면, 그 컴포넌트만 바꾸면 되므로 일일이 수정해야 하는 <code class="language-plaintext highlighter-rouge">shotgun surgery</code> 문제가 발생하지 않는다.</p>

<h3 id="shotgun-surgery">shotgun surgery</h3>

<p>한 개의 문제가 수많은 파일을 동시에 해결해야 하는 현상을 말한다.</p>

<p>전에 진행했던 프로젝트 중에 실제로 이런 문제와 마주친 적이 있었다. 날짜 라이브러리를 변경해야 하는 상황이었는데, 필요한 곳마다 직접 라이브러리를 불러오다보니 라이브러리가 사용된 모든 코드를 변경해야 하는 문제가 발생했다. 그후에 라이브러리를 불러와서 날짜 형식을 지정하는 코드를 한 파일로 분리해서 만들고, 그 파일을 불러온 곳에서는 사용만 할 수 있도록 바꿔서 똑같은 문제가 일어나지 않도록 다시 코드를 수정해야 했다.</p>

<p>컴포넌트도 마찬가지로 같은 기능을 가졌다면 분리해서 문제가 생겨도 그 하나의 컴포넌트만 수정하도록 만드는 것이 중요하다.</p>

<h2 id="선언형-프로그래밍">선언형 프로그래밍</h2>

<p>선언형 프로그래밍은 코드가 어떻게 실행되는지 구체적인 방법을 명시하지 않고, 이 코드가 어떤 역할을 하는지 나타내는 프로그래밍 방식이다.</p>

<p>선언형 프로그래밍와 대비되는 개념으로 명령형 프로그래밍이 있는데, 명령형 프로그래밍은 프로그램의 구체적인 실행 방법을 명시하는 방법이다.</p>

<p>예를 들어, 집을 청소한다고 할 때 선언형 방식은 ‘집을 깨끗하게 유지한다’는 목표를 선언하고, 명령형 방식은 ‘바닥을 쓸고, 창문을 닦아라’ 하는 식으로 구체적인 방법을 명령하는 방식이다.</p>

<p>선언형 프로그래밍 방식을 사용하면 구체적인 실행 방법보다 문제 해결에 더 중점을 두기 때문에 코드가 더 직관적이고, 가독성도 좋다.</p>

<p>다음은 JSX를 이용하여 Greeting이라는 컴포넌트를 만든 코드이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Greeting</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Hello</span><span class="p">,</span> <span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">!&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span><span class="p">}</span>
</code></pre></div></div>

<p>만약 이 코드를 자바스크립트로 구현해야 한다면 이렇게 될 것이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Greeting</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">h1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">h1</span><span class="dl">"</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s2">`Hello, </span><span class="p">${</span><span class="nx">props</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">!`</span><span class="p">)</span>
  <span class="nx">h1</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">h1</span>
<span class="p">}</span>
</code></pre></div></div>

<p>리액트를 사용하면 DOM을 직접 어떻게 조작하는지 일일이 정해주지 않아도 내부적으로 처리해주기 때문에 UI를 정의하는 것에 집중할 수 있다.</p>

<h2 id="virtual-dom">virtual DOM</h2>

<p>리액트는 가상 돔을 사용한다. 가상 돔은 원본의 복사본이라고 생각하면 된다.</p>

<p>예를 들어 가구 배치를 바꾼다고 하자. 가구들을 여러 개 옮길 때 하나씩 옮기다보면 매번 가구를 옮기고, 또 다음 가구를 옮기면서 이미 옮긴 가구를 다시 옮겨야 할 수도 있다. 하지만 만약 가구들을 모형으로 만들어 모형을 이용해 어떻게 배치할 지 정한 후 한번에 옮기면, 여러 번 옮길 필요 없이 정확히 바뀐 부분만 이동해주면 된다. 리액트도 이런 식으로 동작하여 연산 비용을 줄이고 필요한 UI만 업데이트할 수 있다.</p>

<h1 id="create-react-app을-이용하여-리액트-앱을-설치하기">create-react-app을 이용하여 리액트 앱을 설치하기</h1>

<h2 id="create-react-app">create-react-app</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">create</span><span class="o">-</span><span class="nx">react</span><span class="o">-</span><span class="nx">app</span> <span class="o">&lt;</span><span class="nx">프로젝트</span> <span class="nx">이름</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>위의 명령어를 이용해 리액트 앱을 설치하면, 자동으로 package.json, node_modules 등 필요한 파일과 패키지가 설치되어 있을 것이다.</p>

<p>설치 후에 터미널에 <code class="language-plaintext highlighter-rouge">npm start</code>를 입력하면, 자동으로 3000번 포트가 열리면서 웹페이지가 열린다.
(localhost:3000은 내 컴퓨터의 주소를 의미한다.)</p>

<p>리액트 로고가 보이면 성공적으로 설치가 된 것이다.</p>

<h2 id="npx">npx</h2>

<p><code class="language-plaintext highlighter-rouge">create-react-app</code>은 보통 npm보다는 npx 명령어를 이용하여 설치한다.
npx를 사용하면 컴퓨터에 패키지를 설치하지 않고 일시적으로 이용할 수 있는데, 이렇게 하는 이유는 <code class="language-plaintext highlighter-rouge">create-react-app</code>이 자주 업데이트 되기 때문이다. 만약 컴퓨터에 설치하고 사용하면, 버전이 업데이트 되었을 때 수동으로 업데이트를 해줘야 할 것이다. 그러므로 프로젝트를 생성할 때 한 번만 사용하기 위해 npx로 설치하는 것이 편리하다.</p>

<p>npx도 버전 확인을 통해 설치 여부를 확인할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="o">-</span> <span class="nx">v</span>
</code></pre></div></div>

<p>만약 제대로 설치되어 있지 않다면 <code class="language-plaintext highlighter-rouge">npm install -g npx</code> 명령어를 터미널에 입력하여 설치해주면 된다.</p>

<h1 id="jsx">JSX</h1>

<h2 id="jsxjavascript-xml">JSX(JavaScript XML)</h2>

<p>JSX는 자바스크립트 XML을 추가한 확장 문법이다. 확장한다는 의미는 JSX가 공식적인 자바스크립트 문법은 아니라는 의미이다. 리액트에서는 JSX 문법을 사용한 코드를 컴파일 단계에서 Babel과 같은 도구를 이용하여 자바스크립트로 변환하여 실행한다.</p>

<p>XML은 eXtensible Markup Language의 약자로, HTML과 같은 마크업 언어의 한 종류이다. HTML과 다른 점은 태그 이름이 미리 정의되어 있지 않아 사용자가 직접 태그 이름을 지정할 수 있다.</p>

<p class="notice--primary">그런데 JSX에서 &lt;h2&gt;나 <img /> 태그들을 정의하지 않고 사용할 수 있는 것은 React에 HTML과 비슷한 구조를 가지는 JSX 태그들이 미리 정의되어 있기 때문이다.</p>

<h2 id="jsx-문법">JSX 문법</h2>

<p>JSX는 다음과 같은 특징을 가진다.</p>

<ol>
  <li>JSX 태그는 반드시 닫는 태그를 가져야 한다.</li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// &lt;div&gt;Hello World //error</span>
<span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Hello</span> <span class="nx">World</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">img</span> <span class="o">/&gt;</span> <span class="c1">//이렇게 적을 수도 있다.</span>
</code></pre></div></div>

<ol>
  <li>반드시 최상위 태그가 필요하다.</li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="c1">// 최상위 태그</span>
    <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">App</span><span class="dl">"</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Header</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">Footer</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>만약 다른 태그를 모두 감싸는 최상위 태그가 없으면 에러가 발생한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="c1">//error</span>
      <span class="o">&lt;</span><span class="nx">Header</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">Footer</span> <span class="o">/&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>최상위 태그로 <code class="language-plaintext highlighter-rouge">div</code> 등을 사용하고 싶지 않으면 <code class="language-plaintext highlighter-rouge">fragment</code> 태그를 사용하면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span> <span class="c1">//React를 import 해야 한다.</span>
<span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">React</span><span class="p">.</span><span class="nx">Fragment</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Header</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">Footer</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/React.Fragment</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;&gt;</code> 형태로 사용해도 된다. 이 경우에는 JSX 컴파일러(바벨 같은..)가 <code class="language-plaintext highlighter-rouge">fragment</code>를 자동으로 인식해서 <code class="language-plaintext highlighter-rouge">import</code> 하지 않아도 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">Header</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">Footer</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">css</code>에서 <code class="language-plaintext highlighter-rouge">class</code> 대신 <code class="language-plaintext highlighter-rouge">className</code>을 사용해야 한다.</li>
</ol>

<p>리액트에서 class 속성을 사용하면 자바스크립트의 클래스와 혼동될 수 있기 떄문에 <code class="language-plaintext highlighter-rouge">className</code> 속성을 사용해야 한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Header.js</span>
<span class="k">import</span> <span class="dl">"</span><span class="s2">./Header.css</span><span class="dl">"</span>

<span class="kd">const</span> <span class="nx">Header</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">header</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">header</span><span class="dl">"</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Hello</span> <span class="nx">React</span><span class="o">!&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/header</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Header.css</span>
<span class="p">.</span><span class="nx">header</span> <span class="p">{</span>
  <span class="nx">background</span><span class="o">-</span><span class="nx">color</span><span class="p">:</span> <span class="nx">aliceblue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>JSX에서 자바스크립트의 값을 사용하는 방법</li>
</ol>

<p>JSX내에서 자바스크립트의 값을 사용하려면, 중괄호로 값을 감싸면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">jack</span><span class="dl">"</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Hello</span><span class="p">,</span> <span class="p">{</span><span class="nx">name</span><span class="p">}</span><span class="o">!&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>중괄호 안에 함수를 넣을 수도 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span>
  <span class="kd">const</span> <span class="nx">func</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Hello</span><span class="p">,</span> <span class="p">{</span><span class="nx">name</span><span class="p">}</span><span class="o">!&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">func</span><span class="p">()}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>또한 삼항연산자도 사용할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">isLoggedIn</span> <span class="p">?</span> <span class="o">&lt;</span><span class="nx">AdminPanel</span> <span class="o">/&gt;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="nx">LoginForm</span> <span class="o">/&gt;</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div></div>

<p>위의 코드처럼 삼항연산자를 이용하여 로그인이 되어 있는지, 아닌지에 따라 다른 컴포넌트를 렌더링할 수 있다.</p>

<h1 id="state">State</h1>

<p>State는 계속 변화하는 데이터를 가리킨다. 예를 들어 흔히 사용되는 다크 모드의 경우 다크 모드인 상태와, 다크 모드가 아닌 상태로 나눌 수 있으며, 버튼을 통해 상태를 변경할 수 있다.</p>

<p>간단한 예제로, 버튼을 클릭할 때마다 숫자가 1씩 증가하거나 감소하는 컴포넌트를 만들어보자</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span><span class="nx">useState</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span>

<span class="kd">const</span> <span class="nx">Counter</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">//[상태값, 상태 변화 함수] = usesState(초기값)</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

  <span class="kd">const</span> <span class="nx">onIncrease</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">onDecrease</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">onIncrease</span><span class="p">}</span><span class="o">&gt;+&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">onDecrease</span><span class="p">}</span><span class="o">&gt;-&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Counter</span>
</code></pre></div></div>

<p>리액트에서 상태를 변화시키려면 <code class="language-plaintext highlighter-rouge">useState</code>를 사용하면 된다. <code class="language-plaintext highlighter-rouge">useState</code>는 상태의 초기값을 인자로 받아, 배열을 반환한다. 배열의 첫 번째 요소는 <code class="language-plaintext highlighter-rouge">현재 상태 값</code>이고, 두 번째 요소는 <code class="language-plaintext highlighter-rouge">상태를 업데이트하는 함수</code>이다. <code class="language-plaintext highlighter-rouge">useState</code>를 사용하려면 먼저 불러와서 선언해야 한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span><span class="nx">useState</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span>

<span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>다음으로는 함수를 만들어서 버튼을 클릭했을 때 함수가 실행되도록 지정해준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">onIncrease</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{}</span> <span class="c1">//버튼 클릭 시 실행</span>
<span class="p">...</span>
<span class="k">return</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">onIncrease</span><span class="p">}</span><span class="o">&gt;+&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span><span class="p">)</span>
</code></pre></div></div>

<p>그리고 함수가 실행되었을 때 상태가 변경되도록 <code class="language-plaintext highlighter-rouge">setCount</code>를 지정해주면 <code class="language-plaintext highlighter-rouge">setCount</code>에 인자로 넣어준 값으로 <code class="language-plaintext highlighter-rouge">count</code>를 변경해준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">onIncrease</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>이때 <code class="language-plaintext highlighter-rouge">state</code>가 바뀌면 컴포넌트가 리렌더링된다. 화면을 다시 그리면서 변한 상태(여기서는 1을 더한 값)를 반영해서 숫자가 점점 올라갈 수 있는 것이다.</p>

<h1 id="props">Props</h1>

<p>props는 리액트에서 컴포넌트간 데이터를 전달할 때 사용하는 객체이다.</p>

<p>props를 사용하기 위해서는 (1) 데이터를 내려주는 과정, (2) 데이터를 받아오는 과정 두 가지 과정이 필요하다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Parent 컴포넌트</span>
<span class="kd">function</span> <span class="nx">Parent</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="cm">/* props로 내려주는 과정 */</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="nx">Child</span> <span class="nx">name</span><span class="o">=</span><span class="dl">"</span><span class="s2">jack</span><span class="dl">"</span> <span class="nx">age</span><span class="o">=</span><span class="p">{</span><span class="mi">30</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Child 컴포넌트</span>
<span class="kd">function</span> <span class="nx">Child</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="c1">//{ name: "jack", age: 30 }</span>
  <span class="c1">//인자로 받아오는 과정</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Name</span><span class="p">:</span> <span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Age</span><span class="p">:</span> <span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">age</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="default-props">default props</h2>

<p>props로 내려주는 과정에서 값을 내려주지 않을 경우 디폴트로 값을 설정하기 위해서는 이렇게 하면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//props로 아무것도 내려주지 않을 떄</span>
<span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">}</span>

<span class="nx">MyComponent</span><span class="p">.</span><span class="nx">defaultProps</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">message</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Reyna</name></author><category term="lecture" /><category term="udemy" /><category term="react" /><summary type="html"><![CDATA[react]]></summary></entry><entry><title type="html">[Mini Project] 감성 일기장 업그레이드 3. Header, Button 컴포넌트에 타입스크립트 적용하기</title><link href="http://localhost:4000/mini%20project/emotion-diary-3/" rel="alternate" type="text/html" title="[Mini Project] 감성 일기장 업그레이드 3. Header, Button 컴포넌트에 타입스크립트 적용하기" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-11T00:00:00+09:00</updated><id>http://localhost:4000/mini%20project/emotion-diary-3</id><content type="html" xml:base="http://localhost:4000/mini%20project/emotion-diary-3/"><![CDATA[<p><img src="https://blog.kakaocdn.net/dn/dYlhpD/btr92s0glXD/7IHzdhiot6la2QFHZhK97K/img.png" data-origin-width="1260" data-origin-height="891" data-filename="제목을-입력해주세요_-003 (1).png" data-mce-src="https://blog.kakaocdn.net/dn/dYlhpD/btr92s0glXD/7IHzdhiot6la2QFHZhK97K/img.png" data-is-animation="false" data-mce-selected="1" /></p>

<p>여러 페이지에서 공통으로 쓰이는 컴포넌트인 헤더와 버튼 컴포넌트를 먼저 ts로 바꿔주려고 한다.</p>

<h1 id="button-컴포넌트">Button 컴포넌트</h1>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">MyButton</span> <span class="o">=</span> <span class="p">{</span><span class="nx">type</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">default</span><span class="dl">"</span><span class="p">,</span> <span class="nx">text</span><span class="p">,</span> <span class="nx">onClick</span><span class="p">}:</span> <span class="nx">MyButtonProps</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">//이상한 타입이면 강제로 디폴트 타입으로 변경</span>
  <span class="kd">const</span> <span class="nx">btnType</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">positive</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">negative</span><span class="dl">"</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">?</span> <span class="nx">type</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">default</span><span class="dl">"</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">button</span>
      <span class="nx">className</span><span class="o">=</span><span class="p">{[</span><span class="dl">"</span><span class="s2">MyButton</span><span class="dl">"</span><span class="p">,</span> <span class="s2">`MyButton_</span><span class="p">${</span><span class="nx">btnType</span><span class="p">}</span><span class="s2">`</span><span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)}</span>
      <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">onClick</span><span class="p">}</span>
    <span class="o">&gt;</span>
      <span class="p">{</span><span class="nx">text</span><span class="p">}</span>
    <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>

<span class="nx">MyButton</span><span class="p">.</span><span class="nx">defaultProps</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">default</span><span class="dl">"</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">MyButton</span>
</code></pre></div></div>

<p>버튼 컴포넌트는 이렇게 되어 있다. 타입과 버튼 이름을 props로 받아서 버튼 색상과 이름을 상황별로 리턴하는 컴포넌트이다. 만약 타입을 지정하지 않으면 디폴트로 지정되는 구조이다.</p>

<p>여기서 문제가 되는 부분은 props였다. 만약 타입을 버튼을 사용하는 쪽에서 정의하는 경우 사용하는 곳마다 써야할 것 같아 버튼 내에서 지정해주기로 했다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">MyButtonProps</span> <span class="p">{</span>
  <span class="nl">type</span><span class="p">?:</span> <span class="dl">"</span><span class="s2">positive</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">negative</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">default</span><span class="dl">"</span>
  <span class="nx">text</span><span class="p">:</span> <span class="kr">string</span>
  <span class="nx">onClick</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">type</code>은 <code class="language-plaintext highlighter-rouge">"positive" | "negative" | "default"</code> 셋 중에 하나가 되므로, 리터럴 타입으로 지정하면 된다. 만약 세 개의 문자열 외의 값이 들어오면 오류가 발생하므로 오타를 방지하는 데에 도움이 된다.
<code class="language-plaintext highlighter-rouge">onClick</code> 속성은 함수가 들어오게 되므로 함수를 지정해주었다.</p>

<p>interface를 정의한 후에 props에 지정해주면 된다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">MyButton</span> <span class="o">=</span> <span class="p">({</span><span class="kd">type</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">default</span><span class="dl">"</span><span class="p">,</span> <span class="nx">text</span><span class="p">,</span> <span class="nx">onClick</span><span class="p">}:</span> <span class="nx">MyButtonProps</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{}</span>
</code></pre></div></div>

<h1 id="header">Header</h1>

<p>헤더 컴포넌트도 버튼 컴포넌트와 거의 유사한 방식으로 props의 타입을 지정해주었다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//js</span>
<span class="kd">const</span> <span class="nx">MyHeader</span> <span class="o">=</span> <span class="p">{</span><span class="nx">headText</span><span class="p">,</span> <span class="nx">leftChild</span><span class="p">,</span> <span class="nx">rightChild</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">header</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">head_btn_left</span><span class="dl">"</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">leftChild</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">head_text</span><span class="dl">"</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">headText</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">head_btn_right</span><span class="dl">"</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">rightChild</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/header</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">MyHeader</span>
</code></pre></div></div>

<p>헤더의 경우 <code class="language-plaintext highlighter-rouge">leftChild</code>와 <code class="language-plaintext highlighter-rouge">rightChild</code>에 버튼 컴포넌트가 내려온다. 예를 들어 Home 페이지에서는 다음처럼 내려준다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Home.jsx</span>
<span class="o">&lt;</span><span class="nx">MyHeader</span>
  <span class="nx">headText</span><span class="o">=</span><span class="p">{</span><span class="nx">headText</span><span class="p">}</span>
  <span class="nx">leftChild</span><span class="o">=</span><span class="p">{</span><span class="o">&lt;</span><span class="nx">MyButton</span> <span class="nx">text</span><span class="o">=</span><span class="p">{</span><span class="dl">"</span><span class="s2">&lt;</span><span class="dl">"</span><span class="p">}</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">decreaseMonth</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">}
</span>  <span class="nx">rightChild</span><span class="o">=</span><span class="p">{</span><span class="o">&lt;</span><span class="nx">MyButton</span> <span class="nx">text</span><span class="o">=</span><span class="p">{</span><span class="dl">"</span><span class="s2">&gt;</span><span class="dl">"</span><span class="p">}</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">increaseMonth</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">}
</span><span class="o">/&gt;</span>
</code></pre></div></div>

<p>따라서 타입을 정의할 때는 <code class="language-plaintext highlighter-rouge">JSX.Element</code> 타입을 지정해주면 된다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">MyHeaderProps</span> <span class="p">{</span>
  <span class="nl">headText</span><span class="p">:</span> <span class="kr">string</span>
  <span class="nx">leftChild</span><span class="p">:</span> <span class="nx">JSX</span><span class="p">.</span><span class="nx">Element</span>
  <span class="nx">rightChild</span><span class="p">:</span> <span class="nx">JSX</span><span class="p">.</span><span class="nx">Element</span>
<span class="p">}</span>
</code></pre></div></div>

<p>버튼과 마찬가지로 props에 타입 지정을 해주면 된다.</p>

<p class="notice--primary">참고
<a href="https://typescript-kr.github.io/pages/literal-types.html">문자열 리터럴 타입 (String Literal Types)</a></p>]]></content><author><name>Reyna</name></author><category term="mini project" /><category term="project" /><category term="wanted challenge" /><category term="react" /><category term="typescript" /><summary type="html"><![CDATA[wanted challenge]]></summary></entry><entry><title type="html">[한입 크기로 잘라 먹는 리액트] Node.js 기초 알아보기</title><link href="http://localhost:4000/lecture/node-js/" rel="alternate" type="text/html" title="[한입 크기로 잘라 먹는 리액트] Node.js 기초 알아보기" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/lecture/node-js</id><content type="html" xml:base="http://localhost:4000/lecture/node-js/"><![CDATA[<p><img src="https://user-images.githubusercontent.com/110877564/230762246-7b371050-4dab-4c76-8f1c-45fa39d8a3d4.png" alt="표지" /></p>

<p><a href="https://www.udemy.com/course/winterlood-react-basic/?couponCode=1B3AC13BE3B6AE66BCE1"><mark style="background-color: #ffdce0">한입 크기로 잘라 먹는 리액트(React.js)</mark></a>의 section 4를 복습하면서 node.js의 개념과 사용방법을 간단하게 정리해보려고 한다.</p>

<p><br /></p>

<h1 id="1-nodejs란">1. Node.js란?</h1>

<p>Node.js의 공식 홈페이지를 보면 이렇게 쓰여 있다.
<img width="899" alt="스크린샷 2023-04-09 오후 5 25 36" src="https://user-images.githubusercontent.com/110877564/230762424-cb7ded16-6b3a-4028-a92f-ab52a5c2bee4.png" /></p>

<p>이렇게만 보면 무슨 말인지 알기가 어려우니 하나씩 살펴보자.</p>

<h2 id="chrome">Chrome</h2>

<p>크롬은 브라우저의 종류 중에 하나이다. 다른 브라우저로는 사파리나 파이어폭스 등이 있다.</p>

<p><img width="941" alt="스크린샷 2023-04-09 오후 5 23 11" src="https://user-images.githubusercontent.com/110877564/230762548-63dd9db2-651c-4e6f-b305-ae32151301d7.png" /></p>

<p><br />
브라우저는 HTML 문서를 기반으로 동작한다.기존의 웹페이지에서 자바스크립트는 HTML 문서 안에서 경고창을 띄우거나, 버튼 클릭 등의 간단한 이벤트만 처리할 수 있는 작은 부분을 담당하고 있었다.</p>

<h2 id="v8-엔진">v8 엔진</h2>

<p>v8은 크롬에서 동작하는 자바스크립트 엔진이다. 원래 v8엔진은 브라우저에서만 사용하고 있었지만, 브라우저에서 독립하면서 Node.js가 만들어지는 계기가 되었다.</p>

<h2 id="런타임">런타임</h2>

<p>런타임은 실행 환경을 의미한다.</p>

<p>즉 Node.js는 v8 엔진으로 만들어진, 자바스크립트를 브라우저가 아닌 다른 곳에서도 사용할 수 있도록 만들어진 자바스크립트의 실행 환경을 말한다.</p>

<p><br /></p>

<h1 id="2-nodejs-설치하기">2. Node.js 설치하기</h1>

<p><a href="https://nodejs.org/ko">여기</a>에서 다운로드 가능하다. 두 가지 버전이 있는데 그중 LTS 버전은 Long-Term Support”의 약자로, 장기적인 지원을 제공하는 버전을 의미하고, 현재 버전(current version)은 가장 최신 버전을 의미한다. LTS 버전의 경우 안정적이기 때문에 기업 등에서 많이 사용하고, 최신 기능을 사용하고 싶을 땐 현재 버전을 사용하면 된다.</p>

<p>제대로 설치되었는지 확인하려면 터미널에 <code class="language-plaintext highlighter-rouge">node -v</code>를 입력한다. 버전이 나오면 잘 설치된 것이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">node</span> <span class="o">-</span> <span class="nx">v</span>
</code></pre></div></div>

<p>node.js를 설치하면 npm(node package manager)도 같이 설치가 되는데, 마찬가지로 터미널에 <code class="language-plaintext highlighter-rouge">npm -v</code>를 입력해서 버전이 출력되면 잘 설치되었음을 확인할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npm</span> <span class="o">-</span> <span class="nx">v</span>
</code></pre></div></div>

<p>두 가지 모두 잘 설치되었으면 이제 컴퓨터에서 node.js를 사용할 수 있다.</p>

<p><br /></p>

<h1 id="3-nodejs를-이용해서-vscode에서-hello-world-띄우기">3. node.js를 이용해서 vscode에서 Hello World 띄우기</h1>

<p>이제 실제로 브라우저 밖에서 javascript를 실행해보자. 여기서는 vscode를 사용했는데, 다른 에디터를 사용해도 무방하다.</p>

<ul>
  <li>먼저 vscode에서 js 파일을 만든다.</li>
</ul>

<p><img width="154" alt="스크린샷 2023-04-09 오후 6 09 24" src="https://user-images.githubusercontent.com/110877564/230764591-f06e9a33-9436-40a7-ada5-7cb66530f1a9.png" /></p>

<ul>
  <li>파일을 열고 실행할 javascript를 작성한다.</li>
</ul>

<p><img width="577" alt="스크린샷 2023-04-09 오후 6 09 43" src="https://user-images.githubusercontent.com/110877564/230764593-a029c9fb-d99d-4d6d-a210-8eaace5bbcf4.png" /></p>

<ul>
  <li>터미널에서 <code class="language-plaintext highlighter-rouge">node + 파일 이름</code>을 입력한다. 이 명령어는 node에게 지정한 파일을 실행하라는 의미이다. 그러면 안에 작성했던 코드가 실행된다!</li>
</ul>

<p><img width="436" alt="스크린샷 2023-04-09 오후 6 16 35" src="https://user-images.githubusercontent.com/110877564/230764822-7d576f46-5389-4f6e-bb4e-cdd9ba765ea4.png" /></p>

<h1 id="4-작성한-코드를-내보내고-가져오기">4. 작성한 코드를 내보내고 가져오기</h1>

<p>이번에는 js 파일을 두 개 만들어서, 한 쪽에서 내보낸 코드를 다른 곳에서 사용해보자.</p>

<p><code class="language-plaintext highlighter-rouge">calc.js</code>라는 파일을 만들어서 다음과 같이 입력한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//calc.js</span>
<span class="kd">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
<span class="kd">const</span> <span class="nx">sub</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">moduleName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">calc module</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">add</span><span class="p">,</span>
  <span class="nx">sub</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// module.exports = { add, sub }; //이렇게만 적어도 된다</span>
</code></pre></div></div>

<p>여기에서 module은 다른 파일에서 사용할 수 있는 코드의 묶음을 말한다. 변수, 함수 등의 모듈을 내보내면, 다른 파일에서 가져다가 사용할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">calc</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">./calc</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">calc</span><span class="p">)</span>
</code></pre></div></div>

<p>require 안에 불러올 파일을 지정해서 변수에 담았다. <code class="language-plaintext highlighter-rouge">./</code>는 현재 폴더를 의미한다.</p>

<p>아까처럼 <code class="language-plaintext highlighter-rouge">node index.js</code>를 입력해보면 잘 가져와진다.</p>

<p><img width="436" alt="스크린샷 2023-04-09 오후 6 31 16" src="https://user-images.githubusercontent.com/110877564/230765510-2e63489e-4ced-480d-9c3c-e20be85955ca.png" /></p>

<p>이 안의 함수를 사용하고 싶을 땐 다음처럼 사용하면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">calc</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">./calc</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">calc</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">//3</span>
</code></pre></div></div>

<p>이렇게 아예 처음부터 빼서 쓸 수도 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span><span class="nx">add</span><span class="p">,</span> <span class="nx">sub</span><span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">./calc</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sub</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="commonjs와-es6-모듈">commonJS와 ES6 모듈</h2>

<p>이렇게 <code class="language-plaintext highlighter-rouge">module.exports</code>와 <code class="language-plaintext highlighter-rouge">require()</code> 함수를 사용하여 모듈을 내보내고 가져오는 방법은 <code class="language-plaintext highlighter-rouge">commonJS</code> 모듈 시스템에서 사용되는 방식이다.</p>

<p>모듈 시스템에는 ES6(ES2015)에서 추가된 <code class="language-plaintext highlighter-rouge">ES6 모듈 시스템</code>도 있다.
ES6 모듈도 commonJS과 마찬가지로 내보내고 가져오는 방식인데, <code class="language-plaintext highlighter-rouge">export()</code>와 <code class="language-plaintext highlighter-rouge">import()</code> 키워드를 사용한다.</p>

<p>위에서 작성한 코드를 ES6 모듈로 바꾸면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//calc.js</span>
<span class="kd">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
<span class="kd">const</span> <span class="nx">sub</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span>

<span class="k">export</span> <span class="p">{</span><span class="nx">add</span><span class="p">,</span> <span class="nx">sub</span><span class="p">}</span>

<span class="c1">//index.js</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">add</span><span class="p">,</span> <span class="nx">sub</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./calc.js</span><span class="dl">"</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">// 5</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sub</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">// 2</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="5-npm">5. npm</h1>

<p>위에서 node를 설치할 때 함께 설치된 npm에 대해서도 알아보자.</p>

<h2 id="npmnode-package-manager">npm(node package manager)</h2>

<p>npm은 오픈 소스 라이브러리, 프레임워크, 도구 등을 포함한 수많은 패키지를 설치하고 관리할 수 있게 도와주는 도구이다.</p>

<h2 id="package">package</h2>

<p>패키지는 모듈을 포함하는 파일이나 폴더를 말한다. 다른 사람들이 npm에 올려놓은 복잡한 기능을 수행하는 패키지를 불러와서 사용할 수 있다.</p>

<h2 id="npm-사용해보기">npm 사용해보기</h2>

<h3 id="npm-init">npm init</h3>

<p>에디터에서 폴더를 하나 만들자. 여기를 루트 폴더로 가정하고, 루트 폴더에서 터미널을 연다. 터미널에 <code class="language-plaintext highlighter-rouge">npm init</code>을 입력한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npm</span> <span class="nx">init</span>
</code></pre></div></div>

<p>그러면 여러가지 질문을 하는데, 패키지의 이름이나 설명 등을 물어보는 것이라 입력해주면 된다.</p>

<p><img width="528" alt="스크린샷 2023-04-09 오후 7 33 52" src="https://user-images.githubusercontent.com/110877564/230767810-ff5a0a45-6480-45d3-a057-feb6d535b1ad.png" /></p>

<p>확인까지 끝내고 나면 루트 폴더에 <code class="language-plaintext highlighter-rouge">package.json</code>이라는 파일이 하나 생긴다. 이 파일은 패키지의 환경을 설정하는 파일이라고 생각하면 된다.</p>

<p><code class="language-plaintext highlighter-rouge">package.json</code>에는 여러 정보가 기입되어 있는데, 그중 <code class="language-plaintext highlighter-rouge">script</code>에는 자주 사용하는 명령어를 지정할 수 있다.</p>

<p>예를 들어 다음처럼 start를 설정하고 터미널에서 <code class="language-plaintext highlighter-rouge">npm start</code>를 입력하면, <code class="language-plaintext highlighter-rouge">node index.js</code>가 실행된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="dl">"</span><span class="s2">scripts</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">start</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">node index.js</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">},</span>
</code></pre></div></div>

<h3 id="패키지-설치">패키지 설치</h3>

<p>다른 사람이 만든 패키지를 사용하기 위해서는 <a href="https://www.npmjs.com/">npm</a>를 이용하면 된다. 이 사이트에서 필요한 패키지를 검색하면 된다.</p>

<p><img width="1348" alt="스크린샷 2023-04-09 오후 7 44 31" src="https://user-images.githubusercontent.com/110877564/230768159-c8357b7f-1db8-4bc1-b08a-23f7ed75f1f1.png" /></p>

<p>예를 들어 이 패키지를 사용하면 색상 코드를 랜덤하게 주는 모듈을 사용할 수 있다. 우측에 나와 있는 <code class="language-plaintext highlighter-rouge">npm i randomcolor</code> 명령어를 복사해서 터미널에 입력해서 설치할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npm</span> <span class="nx">i</span> <span class="nx">randomcolor</span>
</code></pre></div></div>

<p>설치가 완료되면 <code class="language-plaintext highlighter-rouge">package.json</code>에 다음과 같은 코드가 추가되어 있을 것이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="dl">"</span><span class="s2">dependencies</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">randomcolor</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">^0.6.2</span><span class="dl">"</span>
  <span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">"^0.6.2"</code>는 패키지의 버전을 뜻하는데, <code class="language-plaintext highlighter-rouge">^</code>는 <code class="language-plaintext highlighter-rouge">0.6.2</code> 버전 이상으로 설치가 되었다는 의미이다.</p>

<p>그리고 폴더를 살펴보면, node_modules라는 폴더도 만들어져 있을 것이다.</p>

<p><img width="169" alt="스크린샷 2023-04-09 오후 7 51 32" src="https://user-images.githubusercontent.com/110877564/230768405-00943900-5236-4e92-9b1d-cebd071b59fd.png" /></p>

<p><code class="language-plaintext highlighter-rouge">node_modules</code>는 <code class="language-plaintext highlighter-rouge">package.json</code>에 명시되어 있는 패키지들이 실제로 설치되는 폴더이다. 이 안에서 아까 설치한 <code class="language-plaintext highlighter-rouge">randomcolor</code> 패키지의 코드들을 확인할 수 있다. <code class="language-plaintext highlighter-rouge">randomcolor</code>도 패키지이기 때문에 <code class="language-plaintext highlighter-rouge">package.json</code> 폴더를 가지고 있으며, 그 안에 패키지의 정보가 적혀 있다.</p>

<p>마지막으로 package-lock.json 파일도 확인할 수 있는데, 여기에는 정확히 어떤 버전의 패키지가 설치되어 있는지 적혀 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="dl">"</span><span class="s2">node_modules/randomcolor</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">"</span><span class="s2">version</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">0.6.2</span><span class="dl">"</span><span class="p">,</span>
      <span class="dl">"</span><span class="s2">resolved</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">https://registry.npmjs.org/randomcolor/-/randomcolor-0.6.2.tgz</span><span class="dl">"</span><span class="p">,</span>
      <span class="dl">"</span><span class="s2">integrity</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">sha512-Mn6TbyYpFgwFuQ8KJKqf3bqqY9O1y37/0jgSK/61PUxV4QfIMv0+K2ioq8DfOjkBslcjwSzRfIDEXfzA9aCx7A==</span><span class="dl">"</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 id="설치한-패키지-적용">설치한 패키지 적용</h3>

<p>패키지의 공식 문서를 보면 보통 어떻게 사용하는지 자세히 나와 있다. 공식 문서를 참고해서 다음과 같이 적고 터미널에서 <code class="language-plaintext highlighter-rouge">npm start</code>를 입력하면 색상 코드가 잘 출력되는 것을 볼 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//index.js</span>
<span class="kd">const</span> <span class="nx">randomcolor</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">randomcolor</span><span class="dl">"</span><span class="p">)</span> <span class="c1">//외부 모듈은 경로를 명시할 필요 없음</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">color1:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">randomcolor</span><span class="p">())</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">color2:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">randomcolor</span><span class="p">())</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">color3:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">randomcolor</span><span class="p">())</span>
</code></pre></div></div>

<p><img width="436" alt="스크린샷 2023-04-09 오후 8 03 29" src="https://user-images.githubusercontent.com/110877564/230768823-ba04e197-4697-4eac-8a13-15c5a9dd8dd5.png" /></p>

<p>컬러가 무작위로 잘 나오고 있다.</p>]]></content><author><name>Reyna</name></author><category term="lecture" /><category term="udemy" /><category term="node.js" /><summary type="html"><![CDATA[Node.js]]></summary></entry></feed>