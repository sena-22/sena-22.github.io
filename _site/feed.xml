<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-26T22:36:01+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Reyna</title><subtitle>An amazing website.</subtitle><author><name>Reyna</name></author><entry><title type="html">[Programmers] 10. 자연수 뒤집어 배열로 만들기 (javascript)</title><link href="http://localhost:4000/programmers/1-natural-to-array/" rel="alternate" type="text/html" title="[Programmers] 10. 자연수 뒤집어 배열로 만들기 (javascript)" /><published>2023-02-26T00:00:00+09:00</published><updated>2023-02-26T00:00:00+09:00</updated><id>http://localhost:4000/programmers/1-natural-to-array</id><content type="html" xml:base="http://localhost:4000/programmers/1-natural-to-array/"><![CDATA[<h2 id="-문제">🤔 문제</h2>

<p>자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요. 예를들어 n이 12345이면 [5,4,3,2,1]을 리턴합니다.</p>

<h2 id="제한사항">제한사항</h2>

<ul>
  <li>n은 10,000,000,000이하인 자연수입니다.</li>
</ul>

<h2 id="입출력-예시">입출력 예시</h2>

<table>
  <thead>
    <tr>
      <th>n</th>
      <th>return</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>12345</td>
      <td>[5,4,3,2,1]</td>
    </tr>
  </tbody>
</table>

<h2 id="의사코드">의사코드</h2>

<ol>
  <li>빈 배열 생성</li>
  <li>n을 배열로 만들기</li>
  <li>배열의 앞쪽부터 하나씩 빼서 새로운 배열의 맨 앞에 넣기</li>
</ol>

<h2 id="제출한-답">제출한 답</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nx">n</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="dl">""</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">el</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">el</span><span class="p">)));</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="notice--danger">💡 알고리즘 스터디 Recursive에서 공부한 내용 정리</p>

<p>예전 풀이</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nx">n</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="nx">n</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">n</span><span class="p">[</span><span class="nx">i</span><span class="p">]));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Reyna</name></author><category term="programmers" /><category term="study" /><category term="recursive" /><category term="javascript" /><category term="Lv.1" /><summary type="html"><![CDATA[자연수 뒤집어 배열로 만들기]]></summary></entry><entry><title type="html">[typescript] class</title><link href="http://localhost:4000/typescript/class/" rel="alternate" type="text/html" title="[typescript] class" /><published>2023-02-26T00:00:00+09:00</published><updated>2023-02-26T00:00:00+09:00</updated><id>http://localhost:4000/typescript/class</id><content type="html" xml:base="http://localhost:4000/typescript/class/"><![CDATA[<h1 id="클래스">클래스</h1>

<h2 id="클래스-정의하기">클래스 정의하기</h2>

<p>typescript에서 class를 선언할 때, 멤버 변수는 미리 선언해주어야 한다.</p>

<ol>
  <li>title:string;</li>
  <li>public 혹은 readonly를 적어주는 방법도 있다</li>
</ol>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Book</span> <span class="p">{</span>
  <span class="c1">// 1. title:string;</span>
  <span class="nl">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

  <span class="cm">/* 생성자 */</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="nx">title</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* 클래스 메서드*/</span>
  <span class="k">static</span> <span class="nx">create</span><span class="p">()</span> <span class="p">{}</span>

  <span class="cm">/* 인스턴스 메서드*/</span>
  <span class="nx">init</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 2. public 혹은 readonly를 적어주는 방법도 있다</span>
<span class="kd">class</span> <span class="nx">Book</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="nx">title</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="접근-제한자접근-제어자">접근 제한자(접근 제어자)</h2>

<p>javascript에는 없는 기능으로, 접근 가능한 범위를 설정할 수 있다.</p>

<ol>
  <li>public - 자식 클래스, 클래스 인스턴스 모두 접근 가능(생략 가능하다)</li>
  <li>protected - 자식 클래스에서 접근 가능</li>
  <li>private - 해당 클래스 내부에서만 접근 가능(<code class="language-plaintext highlighter-rouge">#</code>으로 대체 가능)</li>
</ol>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Book</span> <span class="p">{</span>
  <span class="c1">//public</span>
  <span class="k">public</span> <span class="nx">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

  <span class="c1">//public은 생략 가능</span>
  <span class="nl">author</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

  <span class="c1">//private : Book 클래스 내부에서만 접근 가능</span>
  <span class="k">private</span> <span class="nx">public_year</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

  <span class="c1">//protected : Book 클래스와 자식 클래스에서 접근 가능</span>
  <span class="k">protected</span> <span class="nx">paper_type</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

  <span class="kd">constructor</span><span class="p">(</span><span class="nx">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">author</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="k">public</span> <span class="nx">pages</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="nx">title</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">author</span> <span class="o">=</span> <span class="nx">author</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">pages</span> <span class="o">=</span> <span class="nx">pages</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">paper_type</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">public_year</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 인스턴스 생성*/</span>
<span class="kd">let</span> <span class="nx">mythology</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Book</span><span class="p">(</span><span class="dl">"</span><span class="s2">mythology1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">sena</span><span class="dl">"</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mythology</span><span class="p">);</span> <span class="c1">//Book: {}</span>
</code></pre></div></div>

<h1 id="추상-클래스">추상 클래스</h1>

<h2 id="추상-클래스-1">추상 클래스</h2>

<p>추상 클래스는 상위 수준에 집중하고 하위 수준의 세부적인 사항을 미리 구현할 필요가 없어 복잡성을 최소화하고 설계에 집중할 수 있게 해준다.
여기서 상위 수준이 추상 클래스가 되고, 하위 수준은 추상 클래스를 상속하는 구체 클래스가 된다.</p>

<p>추상 클래스를 정의할 때는 <code class="language-plaintext highlighter-rouge">abstract</code>라는 키워드를 사용한다</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

  <span class="kd">constructor</span><span class="p">(</span><span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* 
    추상 메서드 정의
    추상 클래스 내부의 추상 메서드는 상속받은 쪽에서 구현해줘야 한다.
  */</span>
  <span class="kd">abstract</span> <span class="nx">sleep</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>

  <span class="c1">//일반 메서드 정의</span>
  <span class="nx">move</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">moving...</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>추상 클래스는 객체로 생성할 수 없다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nx">Animal</span><span class="p">();</span> <span class="c1">//Cannot create an instance of an abstract class.</span>
</code></pre></div></div>

<p>따라서 구체 클래스를 생성해주어야 한다. 추상 클래스를 상속할 때는 <code class="language-plaintext highlighter-rouge">extends</code>라는 키워드를 사용한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Rabbit</span> <span class="kd">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">sleep</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">sleeping...</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">rabbit</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rabbit</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rabbit</span><span class="p">);</span> <span class="c1">//Rabbit:{"age:3"}</span>
</code></pre></div></div>

<p class="notice--primary">💡 참고 <br />
<a href="https://yamoo9.gitbook.io/typescript/classes">Typescript Guidbook</a> <br />
<a href="https://developer-talk.tistory.com/368">DevStory</a> <br />
<a href="https://poiemaweb.com/typescript-class">poiemaweb</a> <br />
<a href="https://www.youtube.com/watch?v=17Oh028Jpis&amp;list=PLZKTXPmaJk8KhKQ_BILr1JKCJbR0EGlx0&amp;index=6">코딩앙마 youtube Typescript #6 클래스</a> <br /></p>]]></content><author><name>Reyna</name></author><category term="typescript" /><category term="typescript" /><category term="class" /><category term="member visibility" /><category term="abstract class" /><summary type="html"><![CDATA[클래스, 접근제한자, 추상 클래스]]></summary></entry><entry><title type="html">[typescript] 리터럴, 유니온, 교차 타입</title><link href="http://localhost:4000/typescript/union-literal-intersection-types/" rel="alternate" type="text/html" title="[typescript] 리터럴, 유니온, 교차 타입" /><published>2023-02-25T00:00:00+09:00</published><updated>2023-02-26T00:00:00+09:00</updated><id>http://localhost:4000/typescript/union-literal-intersection-types</id><content type="html" xml:base="http://localhost:4000/typescript/union-literal-intersection-types/"><![CDATA[<h1 id="리터럴-타입">리터럴 타입</h1>

<p>리터럴 타입은 구체적인 문자열과 숫자 값을 타입으로 지정하여, 지정한 값만 사용할 수 있게 만든 타입이다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//const로 선언한 원시 값은 재할당이 불가능하다.</span>
<span class="c1">// 리터럴 타입의 표현 방식은 const 키워드가 작동하는 방식과 유사하다.</span>
<span class="kd">const</span> <span class="nx">userName1</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">jack</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">//let으로 선언한 값은 재할당이 가능하다. 이 경우 숫자도 함께 지정했기 때문에 숫자로 재할당이 가능하다</span>
<span class="kd">let</span> <span class="nx">userName2</span> <span class="o">=</span> <span class="kr">string</span><span class="o">|</span><span class="kr">number</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">clive</span><span class="dl">'</span>
<span class="nx">userName2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">Job</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">police</span><span class="dl">'</span> <span class="o">|</span><span class="dl">'</span><span class="s1">developer</span><span class="dl">'</span><span class="o">|</span><span class="dl">'</span><span class="s1">teacher</span><span class="dl">'</span><span class="p">;</span> <span class="c1">//리터럴 타입</span>

<span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span><span class="kr">string</span><span class="p">;</span>
  <span class="nl">job</span><span class="p">:</span><span class="nx">Job</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">user</span><span class="p">:</span><span class="nx">User</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">Jack</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">job</span><span class="p">:</span><span class="dl">'</span><span class="s1">developer</span><span class="dl">'</span> <span class="c1">//위에서 선언한 목록만 사용 가능하다.</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="유니언-타입">유니언 타입</h1>

<p>유니언 타입은 타입을 조합하는 방법 중에 하나이며, <code class="language-plaintext highlighter-rouge">or</code> 조건을 나타낼 때 사용한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Car</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">car</span><span class="dl">"</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nx">start</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Mobile</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">mobile</span><span class="dl">"</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nx">call</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//Car | Mobile처럼 |를 사용한 타입을 유니온타입이라고 한다.</span>
<span class="kd">function</span> <span class="nx">getGift</span><span class="p">(</span><span class="nx">gift</span><span class="p">:</span> <span class="nx">Car</span> <span class="o">|</span> <span class="nx">Mobile</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">gift</span><span class="p">.</span><span class="nx">color</span><span class="p">);</span> <span class="c1">//둘다 가지고 있는 속성은 사용 가능</span>
  <span class="nx">gift</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span> <span class="c1">// 하나에만 있는 속성은 사용 불가능 (에러 발생)</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">gift</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">car</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//이런 식으로 조건문을 달아서 사용 가능</span>
    <span class="nx">gift</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">gift</span><span class="p">.</span><span class="nx">call</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="교차-타입">교차 타입</h1>

<p>유니언 타입과 마찬가지로 타입을 조합할 수 있는데, <code class="language-plaintext highlighter-rouge">and</code> 조건을 나타낼 때 사용한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Car2</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nx">start</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Toy</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">price</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//Toy와 Car의 모든 속성을 적어줘야 한다</span>
<span class="kd">const</span> <span class="nx">toyCar</span><span class="p">:</span> <span class="nx">Toy</span> <span class="o">&amp;</span> <span class="nx">Car2</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">tayo</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">start</span><span class="p">()</span> <span class="p">{},</span>
  <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">blue</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">price</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name>Reyna</name></author><category term="typescript" /><category term="typescript" /><category term="literal type" /><category term="union type" /><category term="intersection type" /><summary type="html"><![CDATA[literal, union, intersection type]]></summary></entry><entry><title type="html">[Deep Dive] 6. 연산자</title><link href="http://localhost:4000/javascript/operator/" rel="alternate" type="text/html" title="[Deep Dive] 6. 연산자" /><published>2023-02-25T00:00:00+09:00</published><updated>2023-02-25T00:00:00+09:00</updated><id>http://localhost:4000/javascript/operator</id><content type="html" xml:base="http://localhost:4000/javascript/operator/"><![CDATA[<h1 id="연산자와-피연산자">연산자와 피연산자</h1>

<p>연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교 등을 수행하여 하나의 값을 만든다. 이때 대상이 되는 표현식이 피연산자이다. 피연산자는 값으로 평가될 수 있어야 한다.</p>

<h2 id="연산자-표현식">연산자 표현식</h2>

<p>연산자와 피연산자의 조합으로 이루어진 표현식이다. 피연산자와 마찬가지로 값으로 평가될 수 있어야 한다.</p>

<h1 id="1-산술-연산자">1. 산술 연산자</h1>

<p>산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만드는 연산자이다. 산술 연산이 불가능한 경우 NaN을 반환한다.</p>

<h2 id="11-이항-산술-연산자">1.1. 이항 산술 연산자</h2>

<p>2개의 피연산자를 연산하여 숫자 값을 만든다. 피연산자를 바꾸는 부수효과는 없고, 항상 새로운 값을 만든다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 여기서 5와 2는 피연산자, +는 연산자가 된다.</span>
<span class="c1">// 연산을 수행해도 5와 2는 변경되지 않고, 7이라는 새로운 값이 만들어진다.</span>
<span class="mi">5</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 7</span>
</code></pre></div></div>

<p>이항 산술 연산자는 사칙연산과 동일하게 덧셈(<code class="language-plaintext highlighter-rouge">+</code>), 뺄셈(<code class="language-plaintext highlighter-rouge">-</code>), 곱셈(<code class="language-plaintext highlighter-rouge">*</code>), 나눗셈(<code class="language-plaintext highlighter-rouge">/</code>) 등이 있다. <br />
주의할 점은 나눗셈은 <code class="language-plaintext highlighter-rouge">/</code>를 사용하고, 나머지를 구할 때는 <code class="language-plaintext highlighter-rouge">%</code>를 사용한다는 점이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//2.5</span>

<span class="mi">5</span> <span class="o">%</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//1</span>
</code></pre></div></div>

<h2 id="12-단항-산술-연산자">1.2. 단항 산술 연산자</h2>

<p>단항 산술 연산자는 1개의 피연산자를 연산해서 숫자 값을 만든다. <br />
증가/감소 연산자인 <code class="language-plaintext highlighter-rouge">++</code>와 <code class="language-plaintext highlighter-rouge">--</code>연산자는 부수효과가 있지만, <code class="language-plaintext highlighter-rouge">+</code>와 <code class="language-plaintext highlighter-rouge">-</code> 연산자는 부수효과를 가지지 않는다.</p>

<h3 id="--"><code class="language-plaintext highlighter-rouge">++/--</code></h3>

<p>증가/감소 연산자는 위치에 따라 다른 효과를 가진다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">result</span><span class="p">;</span>

<span class="c1">// 할당 후 증가</span>
<span class="nx">result</span> <span class="o">=</span> <span class="nx">a</span><span class="o">++</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span> <span class="c1">// 5,6</span>

<span class="c1">// 증가 후 할당</span>
<span class="nx">result</span> <span class="o">=</span> <span class="o">++</span><span class="nx">a</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span> <span class="c1">// 7 7</span>

<span class="c1">// 할당 후 감소</span>
<span class="nx">result</span> <span class="o">=</span> <span class="nx">a</span><span class="o">--</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span> <span class="c1">// 7 6</span>

<span class="c1">// 감소 후 할당</span>
<span class="nx">result</span> <span class="o">=</span> <span class="o">--</span><span class="nx">a</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span> <span class="c1">// 5 5</span>

<span class="c1">//이때 피연산자인 a의 값이 변한다(부수효과를 가진다)</span>
</code></pre></div></div>

<h3><code class="language-plaintext highlighter-rouge">+</code></h3>

<p><code class="language-plaintext highlighter-rouge">+</code> 단항 연산자는 아무런 효과도 없다. 다만 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자로 변환한 값을 생성해서 반환한다.(피연산자를 변경하는 것은 아니다)</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">//숫자로 타입 변환한다</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="o">+</span><span class="nx">x</span><span class="p">);</span> <span class="c1">//number</span>
<span class="c1">//피연산자를 변경하는 것은 아니다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="k">typeof</span> <span class="nx">x</span><span class="p">);</span> <span class="c1">// 1 string</span>

<span class="nx">x</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="o">+</span><span class="nx">x</span><span class="p">);</span> <span class="c1">//1</span>

<span class="c1">// 숫자로 변경하지 못하면 NaN을 반환한다.</span>
<span class="nx">x</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hi</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="o">+</span><span class="nx">x</span><span class="p">);</span> <span class="c1">//NaN</span>
</code></pre></div></div>

<h3 id="-"><code class="language-plaintext highlighter-rouge">-</code></h3>

<p><code class="language-plaintext highlighter-rouge">-</code> 단항 연산자는 부호를 반전한 값을 반환한다. <code class="language-plaintext highlighter-rouge">+</code> 단항 연산자와 마찬가지로 부수 효과는 없다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="o">-</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// -1</span>
</code></pre></div></div>

<h2 id="13-문자열-연결-연산자">1.3. 문자열 연결 연산자</h2>

<p><code class="language-plaintext highlighter-rouge">+</code> 연산자는 피연산자 중에 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
<br /> 이때 타입이 강제로 변환되는 암묵적 타입 변환이 일어나는데, 암묵적 타입 변환은 <a href="https://sena-22.github.io/javascript/2-type/#%EC%95%94%EB%AC%B5%EC%A0%81-%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98">여기</a>에 정리해두었다.</p>

<h1 id="2-할당-연산자">2. 할당 연산자</h1>

<h1 id="3-비교-연산자">3. 비교 연산자</h1>

<h2 id="31-동등-비교-연산자--일치-비교-연산자">3.1. 동등 비교 연산자 / 일치 비교 연산자</h2>

<h3 id="동등-비교-연산자">동등 비교 연산자</h3>

<h3 id="일치-비교-연산자">일치 비교 연산자</h3>

<h2 id="32-대소-관계-비교-연산자">3.2. 대소 관계 비교 연산자</h2>

<h1 id="4-삼항-조건-연산자">4. 삼항 조건 연산자</h1>

<h1 id="5-논리-연산자">5. 논리 연산자</h1>

<h1 id="6-쉼표-연산자">6. 쉼표 연산자</h1>

<h1 id="7-그룹-연산자">7. 그룹 연산자</h1>

<h1 id="8-typeof-연산자">8. typeof 연산자</h1>

<h1 id="9-지수-연산자">9. 지수 연산자</h1>

<h1 id="10-그-외의-연산자">10. 그 외의 연산자</h1>

<h1 id="연산자의-부수-효과">연산자의 부수 효과</h1>

<h1 id="연산자-우선-순위">연산자 우선 순위</h1>

<h1 id="연산자-결합-순서">연산자 결합 순서</h1>

<p class="notice--danger">deep dive 4장, 14장, 15장 참고</p>]]></content><author><name>Reyna</name></author><category term="javascript" /><category term="javascript" /><category term="operator" /><summary type="html"><![CDATA[operator]]></summary></entry><entry><title type="html">[Programmers] 9. 자릿수 더하기 (javascript)</title><link href="http://localhost:4000/programmers/place-value/" rel="alternate" type="text/html" title="[Programmers] 9. 자릿수 더하기 (javascript)" /><published>2023-02-23T00:00:00+09:00</published><updated>2023-02-23T00:00:00+09:00</updated><id>http://localhost:4000/programmers/place-value</id><content type="html" xml:base="http://localhost:4000/programmers/place-value/"><![CDATA[<h2 id="-문제">🤔 문제</h2>

<p>자연수 N이 주어지면, N의 각 자릿수의 합을 구해서 return 하는 solution 함수를 만들어 주세요. <br />
예를들어 N = 123이면 1 + 2 + 3 = 6을 return 하면 됩니다.</p>

<h2 id="제한사항">제한사항</h2>

<ul>
  <li>N의 범위 : 100,000,000 이하의 자연수</li>
</ul>

<h2 id="입출력-예시">입출력 예시</h2>

<table>
  <thead>
    <tr>
      <th>maps</th>
      <th>answer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>123</td>
      <td>6</td>
    </tr>
    <tr>
      <td>987</td>
      <td>24</td>
    </tr>
  </tbody>
</table>

<h2 id="의사코드">의사코드</h2>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Array.from()</code> 메서드를 사용해서 N을 배열로 만든다.</li>
  <li><code class="language-plaintext highlighter-rouge">reduce()</code>로 각 자리의 합을 구한다.</li>
</ol>

<h2 id="제출한-답">제출한 답</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span> <span class="nb">Number</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">cur</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span> <span class="o">+</span> <span class="nx">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="숫자를-배열로-분할하기">숫자를 배열로 분할하기</h2>

<h3 id="1-arrayfrom">1. Array.from()</h3>

<p><code class="language-plaintext highlighter-rouge">Array.from()</code>은 첫 번째 인자로 배열로 바꾸고 싶은 유사배열 객체나 이터러블 객체(인덱스를 가지고, 반복할 수 있는 객체) 를 전달하고, 두 번째 인자로 배열의 모든 요소에 대해 호출되는 함수를 전달한다.
이 문제의 경우 문자열로 변환된 숫자와 Number 생성자를 전달한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Array.from(String(num), Number)</span>
<span class="kd">let</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="mi">12345</span><span class="p">),</span> <span class="nb">Number</span><span class="p">);</span> <span class="c1">//[1, 2, 3, 4, 5]</span>
<span class="c1">// 두 번째 인자를 전달하지 않으면 각 요소가 문자열로 반환된다.</span>
<span class="kd">let</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="mi">12345</span><span class="p">));</span> <span class="c1">//['1', '2', '3', '4', '5']</span>
</code></pre></div></div>

<h3 id="2-split-메서드를-사용하는-방법">2. split 메서드를 사용하는 방법</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">strArr</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="mi">12345</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span> <span class="c1">//['1', '2', '3', '4', '5']</span>
<span class="kd">let</span> <span class="nx">numArr</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="mi">12345</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nb">Number</span><span class="p">);</span> <span class="c1">//[1, 2, 3, 4, 5]</span>
</code></pre></div></div>

<p>숫자를 문자로 변환할 때 String 생성자를 사용하는 방법 외에도 암묵적 타입 변환을 사용하는 방법도 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12345</span> <span class="o">+</span> <span class="dl">""</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nb">Number</span><span class="p">);</span> <span class="c1">//[1, 2, 3, 4, 5]</span>
</code></pre></div></div>

<h2 id="다른-풀이">다른 풀이</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="dl">""</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">).</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">cur</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span> <span class="o">+</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">cur</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>배열을 숫자 타입으로 바꾼 후 reduce를 사용하지 않고 reduce를 사용하면서 요소를 하나씩 숫자 타입으로 바꾼 방법이다.</p>

<p class="notice--primary">💡 <a href="https://sena-22.github.io/javascript/2-type/#1-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%B3%80%ED%99%98">숫자를 문자로 바꾸기</a> <br />
💡 <a href="https://codingbeautydev.com/blog/javascript-split-number-into-array/">JavaScript에서 숫자를 배열로 분할하는 방법</a></p>

<p class="notice--danger">💡 알고리즘 스터디 Recursive에서 공부한 내용 정리</p>]]></content><author><name>Reyna</name></author><category term="programmers" /><category term="study" /><category term="recursive" /><category term="javascript" /><category term="Lv.1" /><summary type="html"><![CDATA[자릿수 더하기]]></summary></entry><entry><title type="html">[Deep Dive] 4. 표현식</title><link href="http://localhost:4000/javascript/1-expression/" rel="alternate" type="text/html" title="[Deep Dive] 4. 표현식" /><published>2023-02-23T00:00:00+09:00</published><updated>2023-02-23T00:00:00+09:00</updated><id>http://localhost:4000/javascript/1-expression</id><content type="html" xml:base="http://localhost:4000/javascript/1-expression/"><![CDATA[<h2 id="1-값">1. 값</h2>

<h3 id="값">값</h3>

<ul>
  <li>표현식이 평가되어 생성된 결과</li>
</ul>

<h3 id="평가">평가</h3>

<ul>
  <li>식을 해석해서 값을 생성하거나 참조하는 것</li>
</ul>

<h2 id="2-표현식">2. 표현식</h2>

<h3 id="표현식">표현식</h3>

<ul>
  <li>값으로 평가될 수 있는 문</li>
</ul>

<h3 id="리터럴">리터럴</h3>

<ul>
  <li>사람이 이해할 수 있는 문자 혹은 약속된 기호를 사용해서 값을 생성하는 표기법(notation)</li>
  <li>자바스크립트 엔진이 런타임에 리터럴을 평가해서 값을 생성한다.</li>
  <li>리터럴도 값으로 평가되므로 표현식이다.</li>
</ul>

<h2 id="3-문">3. 문</h2>

<h3 id="토큰">토큰</h3>

<ul>
  <li>문법적인 의미를 가지고, 더 이상 나눌 수 없는 코드의 기본 요소</li>
  <li>키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등은 모두 토큰이다.</li>
</ul>

<h3 id="문">문</h3>

<ul>
  <li>프로그램을 구성하는 기본 단위, 최소 실행 단위</li>
  <li>명령문이라고도 한다.</li>
  <li>문은 토큰으로 구성된다.</li>
</ul>

<h3 id="문의-종류">문의 종류</h3>

<ul>
  <li>선언문, 할당문, 조건문, 반복문 등이 있다.</li>
  <li>예를 들어 변수 선언문은 실행하면 변수가 선언되고, 할당문을 실행하면 값이 할당된다.</li>
</ul>

<h2 id="4-세미콜론">4. 세미콜론</h2>

<h3 id="세미콜론">세미콜론</h3>

<ul>
  <li>문을 끝낼 때 붙여야 하며, 문의 종료를 나타낸다.</li>
  <li>생략이 가능하다.</li>
  <li>코드 블록은 자체 종결성을 가지기 때문에 세미콜론을 붙이지 않는다.</li>
</ul>

<h2 id="5-표현식인-문-vs-표현식이-아닌-문">5. 표현식인 문 vs. 표현식이 아닌 문</h2>

<ul>
  <li>표현식은 문의 일부이거나, 그 자체로 문이 될 수 있다.</li>
</ul>

<h3 id="표현식인-문과-표현식이-아닌-문을-구별하는-방법">표현식인 문과 표현식이 아닌 문을 구별하는 방법</h3>

<p>둘을 구별하는 가장 간단한 방법은 <mark>변수에 할당해보는 것</mark>이다.</p>

<ul>
  <li>표현식인 문은 값으로 평가되므로 변수에 할당이 가능하지만, 표현식이 아닌 문은 에러가 발생한다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//변수 선언식은 표현식이 아닌 문이다.</span>
<span class="kd">let</span> <span class="nx">notExpression</span> <span class="o">=</span> <span class="kd">let</span> <span class="nx">x</span> <span class="c1">// 에러가 발생</span>

<span class="c1">//할당문은 표현식인 문이다.</span>
<span class="nx">expression</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></div></div>

<p>크롬 개발자 도구 콘솔 창에서 문을 실행해볼 수도 있다.</p>

<ul>
  <li>표현식인 문은 평가된 값을 반환한다</li>
  <li>표현식이 아닌 문은 <code class="language-plaintext highlighter-rouge">undefined</code>를 반환한다.</li>
  <li>이때 <code class="language-plaintext highlighter-rouge">undefined</code>를 완료 값이라고 한다.</li>
</ul>

<p align="center">
<img width="132" alt="스크린샷 2023-02-23 오전 8 36 31" src="https://user-images.githubusercontent.com/110877564/220787968-36f8c02c-5289-4887-8468-b24da316bcef.png" />
</p>
<p class="notice--danger">deep dive 5장 참고</p>]]></content><author><name>Reyna</name></author><category term="javascript" /><category term="javascript" /><category term="expression" /><summary type="html"><![CDATA[expression]]></summary></entry><entry><title type="html">[Deep Dive] 5. 데이터 타입</title><link href="http://localhost:4000/javascript/2-type/" rel="alternate" type="text/html" title="[Deep Dive] 5. 데이터 타입" /><published>2023-02-23T00:00:00+09:00</published><updated>2023-02-23T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2-type</id><content type="html" xml:base="http://localhost:4000/javascript/2-type/"><![CDATA[<h1 id="1-타입데이터-타입">1. 타입(데이터 타입)</h1>

<ul>
  <li>타입은 값의 종류를 말한다.</li>
  <li>ES6에서는 7개의 타입을 제공하며, 원시 타입과 객체 타입으로 분류할 수 있다.</li>
</ul>

<h2 id="원시-타입primitive-type">원시 타입(primitive type)</h2>

<h3 id="number">number</h3>

<ul>
  <li>javascript는 다른 언어와 달리 하나의 숫자 타입만 존재한다.</li>
  <li>정수만을 위한 타입이 없어 모든 수를 실수로 처리한다.</li>
  <li>양의 무한대(Infinity), 음의 무한대(-Infinity), 산술연산불가(NaN) 표현도 가능하다.</li>
</ul>

<p class="notice--primary">NaN은 대소문자를 꼭 지켜야 한다. nan, NAN처럼 사용하면 식별자로 해석된다.</p>

<h3 id="string">string</h3>

<ul>
  <li>템플릿 리터럴(template literal) : ES6부터 도입된 문자열 표기법. 백틱을 사용해 표현한다.
(1) 멀티라인 문자열</li>
  <li>템플릿 리터럴 내에서 이스케이프 시퀀스를 사용하지 않아도 줄바꿈이 허용된다.</li>
</ul>

<p class="notice--primary">💡 이스케이프 시퀀스 <br />
백스페이스() 뒤에 문자나 숫자 조합이 오는 문자 조합을 말한다. 공백이나 줄바꿈처럼 프로그래밍 언어 특성상 표현하기 어려운 문자열을 표현할 수 있다.
(<code class="language-plaintext highlighter-rouge">\0</code> : null, <code class="language-plaintext highlighter-rouge">\b</code> : 백스페이스…)</p>

<p>(2) 표현식 삽입</p>

<ul>
  <li>문자열 연산자(+)를 사용해서 문자열을 연결하는 방법보다 <code class="language-plaintext highlighter-rouge">${}</code>를 사용해서 표현식을 삽입하면 더 가독성이 좋아진다.</li>
  <li>표현식 삽입은 템플릿 리터럴 내에서 사용해야 하고, 평가 결과가 문자열이 아니어도 문자열로 타입이 강제 변환된다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">front</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">back</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">World</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// 문자열 연산자 사용</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">front</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">back</span><span class="p">);</span> <span class="c1">//Hello World</span>

<span class="c1">//표현식 삽입</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">front</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">back</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span> <span class="c1">//Hello World</span>

<span class="c1">//일반 문자열에서 표현식을 삽입하면 그냥 문자열로 취급된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">${front} ${back}</span><span class="dl">"</span><span class="p">);</span> <span class="c1">//${front} ${back}</span>
</code></pre></div></div>

<h3 id="boolean">boolean</h3>

<ul>
  <li>불리언 타입은 <code class="language-plaintext highlighter-rouge">true</code>와 <code class="language-plaintext highlighter-rouge">false</code> 뿐이다.</li>
</ul>

<h3 id="undefined">undefined</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">undefined</code> 타입은 <code class="language-plaintext highlighter-rouge">undefined</code> 뿐이다.</li>
  <li>변수를 선언하고 값을 할당하지 않으면 <code class="language-plaintext highlighter-rouge">undefined</code>가 반환된다.</li>
  <li>함수에 리턴 값이 없을 때도 <code class="language-plaintext highlighter-rouge">undefined</code>가 반환된다.</li>
</ul>

<h3 id="null">null</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">null</code> 타입은 <code class="language-plaintext highlighter-rouge">null</code> 뿐이다.</li>
  <li><code class="language-plaintext highlighter-rouge">null</code>은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다.</li>
  <li>변수에 <code class="language-plaintext highlighter-rouge">null</code>을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않음을 의미한다.</li>
</ul>

<h3 id="symbol">symbol</h3>

<ul>
  <li>ES6에서 추가된 7번째 타입</li>
  <li>다른 값과 중복되지 않는 유일무이한 값이다.</li>
  <li>Symbol 함수를 호출해서 생성한다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">key</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">"</span><span class="s2">key</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">key</span><span class="p">);</span> <span class="c1">//symbol</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">value</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span> <span class="c1">//value</span>
</code></pre></div></div>

<h2 id="객체-타입">객체 타입</h2>

<p>원시 타입 외의 값은 모두 객체 타입이다.</p>

<h2 id="타입이-왜-필요할까">타입이 왜 필요할까?</h2>

<ul>
  <li>자바스크립트는 데이터 타입에 따라 정해진 크기의 메모리 공간을 확보한다.</li>
  <li>값을 참조할 때 타입에 따라 한 번에 읽어들이는 메모리 공간의 크기가 다르다.</li>
  <li>메모리에서 읽은 2진수의 타입에 따라 해석 방법을 결정한다.</li>
</ul>

<p class="notice--primary">0100 0001을 숫자로 해석하면 65가 되지만, 문자열로 해석하면 ‘A’가 된다.</p>

<h2 id="동적-타이핑">동적 타이핑</h2>

<p>자바스크립트의 변수는 선언이 아닌 할당에 의해 <mark style="background: rgba(27, 31, 35, 0.05)">타입을 추론</mark>하여 결정한다. 그리고 다시 재할당하면 타입이 변한다. 이런 특징을 동적 타이핑이라고 하고, 선언할 때 타입을 선언해야 하는 정적 타입 언어와 구별하여 동적 타입 언어라고 한다.</p>

<h3 id="동적-타입-언어의-단점">동적 타입 언어의 단점</h3>

<ul>
  <li>동적 타입 언어는 개발자의 의도와 다르게 암묵적으로 타입이 변할 수 있다.</li>
</ul>

<h1 id="2-타입-변환">2. 타입 변환</h1>

<ul>
  <li>타입 변환은 개발자의 의도 여부에 따라 명시적 타입 변환과 암묵적 타입 변환으로 나뉜다.</li>
  <li>타입 변환이 기존의 원시 값을 직접 변경하는 것은 아니고,(원시 값은 변경 불가능한 값이다) 기존의 원시 값을 이용해 다른 타입의 새로운 원시 값을 생성한다.</li>
</ul>

<h2 id="명시적-타입-변환">명시적 타입 변환</h2>

<ul>
  <li>개발자가 의도적으로 타입을 변환하는 것을 말한다.</li>
  <li>타입 캐스팅(type casting)이라고도 한다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="nx">num</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">// 명시적 타입 변환</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">num</span><span class="p">,</span> <span class="k">typeof</span> <span class="nx">str</span><span class="p">);</span> <span class="c1">//number string</span>
</code></pre></div></div>

<h3 id="1-문자열-타입으로-변환">1. 문자열 타입으로 변환</h3>

<ul>
  <li>String 생성자 함수를 new 연산자 없이 호출하는 방법</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">String</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// "1"</span>
<span class="nb">String</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// "true"</span>
</code></pre></div></div>

<ul>
  <li>Object.prototype.toString() 메서드를 사용하는 방법</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">// "1"</span>
<span class="kc">true</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">// "true"</span>
</code></pre></div></div>

<ul>
  <li>문자열 연결 연산자를 사용하는 방법(암묵적 타입 변환 이용)</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="dl">""</span><span class="p">;</span> <span class="c1">// "1"</span>
<span class="kc">NaN</span> <span class="o">+</span> <span class="dl">""</span><span class="p">;</span> <span class="c1">// 'NaN'</span>
</code></pre></div></div>

<h3 id="2-숫자-타입으로-변환">2. 숫자 타입으로 변환</h3>

<ul>
  <li>Number 생성자 함수를 new 연산자 없이 호출하는 방법</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Number</span><span class="p">(</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 0</span>
<span class="nb">Number</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// 1</span>
</code></pre></div></div>

<ul>
  <li>parseInt, parseFloat 함수를 사용하는 방법(문자열에만 적용 가능)</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">parseInt</span><span class="p">(</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 0</span>
<span class="nb">parseFloat</span><span class="p">(</span><span class="dl">"</span><span class="s2">10.53</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 10.53</span>
<span class="nb">parseInt</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// NaN</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">+</code> 단항 산술 연산자를 이용하는 방법</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 0</span>
<span class="o">+</span><span class="kc">true</span><span class="p">;</span> <span class="c1">// 1</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">*</code> 산술 연산자를 이용하는 방법</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span> <span class="o">*</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 0</span>
<span class="kc">true</span> <span class="o">*</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 1</span>
</code></pre></div></div>

<h3 id="3-불리언-타입으로-변환">3. 불리언 타입으로 변환</h3>

<ul>
  <li>Boolean 생성자 함수를 new 연산자 없이 호출하는 방법</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Boolean</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">);</span> <span class="c1">//true</span>
<span class="nb">Boolean</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//false</span>
<span class="nb">Boolean</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//true</span>
<span class="nb">Boolean</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">);</span> <span class="c1">//true</span>
<span class="nb">Boolean</span><span class="p">({});</span> <span class="c1">//true</span>
<span class="nb">Boolean</span><span class="p">([]);</span> <span class="c1">//true</span>
<span class="nb">Boolean</span><span class="p">([</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">//true</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">!</code> 부정 논리 연산자를 두 번 사용하는 방법</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">!!</span><span class="dl">"</span><span class="s2">x</span><span class="dl">"</span><span class="p">;</span> <span class="c1">//true</span>
<span class="o">!!</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// false</span>
<span class="o">!!</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// true</span>
<span class="o">!!</span><span class="kc">null</span><span class="p">;</span> <span class="c1">//false</span>
<span class="o">!!</span><span class="p">{};</span> <span class="c1">//true</span>
</code></pre></div></div>

<h2 id="암묵적-타입-변환">암묵적 타입 변환</h2>

<ul>
  <li>자바스크립트 엔진에 의해 암묵적으로 타입이 변하는 것을 말한다.</li>
  <li>타입 강제 변환(type coercion)이라고도 한다.</li>
</ul>

<h3 id="1-문자열-타입으로-변환-1">1. 문자열 타입으로 변환</h3>

<p>문자열 연결 연산자(+)의 피연산자 중에서 문자열 타입이 하나 이상일 때, 문자열 타입이 아닌 피연산자가 있으면 암묵적으로 문자열 타입으로 변환한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">toStr</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="dl">""</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">toStr</span><span class="p">);</span> <span class="c1">//string</span>
</code></pre></div></div>

<h3 id="2-숫자-타입으로-변환-1">2. 숫자 타입으로 변환</h3>

<ul>
  <li>산술 연산자, 비교 연산자, + 단항 연산자의 피연산자는 모두 숫자 타입이어야 하며, 숫자 타입의 값이 아니면 암묵적으로 숫자 타입으로 변환한다.</li>
  <li>만약 숫자 타입으로 변환할 수 없는 경우(객체, 빈 배열이 아닌 배열, undefined) NaN이 반환된다.</li>
  <li>빈 문자열(‘’), 빈 배열([]), null, false는 0으로, true는 1로 변환된다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">5</span><span class="dl">"</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">+</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>문자열 5가 숫자 타입으로 변환된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//prettier-ignore</span>
<span class="dl">""</span> <span class="o">+</span> <span class="c1">// 0</span>
<span class="kc">true</span> <span class="o">+</span> <span class="c1">// 1</span>
<span class="kc">false</span> <span class="o">+</span> <span class="c1">// 0</span>
<span class="p">{}</span> <span class="o">+</span> <span class="c1">// NaN</span>
<span class="p">[]</span> <span class="o">+</span> <span class="c1">// 0</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="c1">// 1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span> <span class="c1">// NaN</span>
</code></pre></div></div>

<h3 id="3-불리언-타입으로-변환-1">3. 불리언 타입으로 변환</h3>

<p>if문이 for문 같은 제어문, 삼항 조건 연산자의 조건식은 불리언 값으로 표현되어야 한다. 따라서 이때 불리언 타입이 아닌 값을 Truthy나 Falsy 값으로 구분하여, Truthy 값은 true로, Falsy 값은 false로 암묵적 타입 변환한다.</p>

<p class="notice--danger"><strong>Falsy 값</strong> <br />
false, undefined, null, 0, -0, NaN, ‘’</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="kc">false</span><span class="p">)</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span> <span class="c1">//false</span>
</code></pre></div></div>

<h1 id="3-단축-평가">3. 단축 평가</h1>

<ul>
  <li>단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 생략하는 것을 말한다.</li>
</ul>

<h2 id="논리-연산자-사용">논리 연산자 사용</h2>

<ul>
  <li>논리합, 논리곱의 연산자 표현식은 언제나 2개의 피연산자 중 한쪽으로 평가된다.</li>
</ul>

<h3 id="논리곱-연산자">논리곱 연산자</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">Apple</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="dl">"</span><span class="s2">Cherry</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 'Cherry'</span>
<span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="dl">"</span><span class="s2">Apple</span><span class="dl">"</span><span class="p">;</span> <span class="c1">//false</span>
<span class="dl">"</span><span class="s2">Apple</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 'false'</span>
</code></pre></div></div>

<ul>
  <li>논리곱(&amp;&amp;) 연산자는 모두 true일 때 true를 반환한다.</li>
  <li>만약 첫 번째 피연산자가 false면 false를 바로 반환한다.</li>
</ul>

<h3 id="논리합-연산자">논리합 연산자</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">Apple</span><span class="dl">"</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">Cherry</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 'Apple'</span>
<span class="kc">false</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">Apple</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 'Apple'</span>
<span class="dl">"</span><span class="s2">Apple</span><span class="dl">"</span> <span class="o">||</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 'Apple'</span>
</code></pre></div></div>

<ul>
  <li>논리합 연산자는 하나만 true여도 true를 반환한다.</li>
  <li>첫 번째 피연산자가 false여도 두 번째 연산자까지 확인한다.</li>
</ul>

<h3 id="단축-평가를-이용하여-if문-대체하기">단축 평가를 이용하여 if문 대체하기</h3>

<ul>
  <li>논리곱 연산자를 이용하면 조건이 Truthy 값일 때 if문을 대체할 수 있다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">done</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>

<span class="c1">// 조건이 참이면 message에 'done'을 할당한다.</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">done</span><span class="p">)</span> <span class="nx">message</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">done</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">//if문 대신 이렇게 쓸 수 있다</span>
<span class="nx">message</span> <span class="o">=</span> <span class="nx">done</span> <span class="o">&amp;&amp;</span> <span class="dl">"</span><span class="s2">done</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// 'done'</span>
</code></pre></div></div>

<ul>
  <li>논리합 연산자를 이용하면 조건이 Falsy일 때 if문을 대체할 수 있다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">done</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">done</span><span class="p">)</span> <span class="nx">message</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">not yet</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">//if문 대신 이렇게 쓸 수 있다</span>
<span class="nx">message</span> <span class="o">=</span> <span class="nx">done</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">not yet</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// false || anything 이므로 anything을 반환</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// 'not yet'</span>
</code></pre></div></div>

<h2 id="옵셔널-체이닝-연산자">옵셔널 체이닝 연산자(?.)</h2>

<ul>
  <li>ES11에서 도입되었다.</li>
  <li><code class="language-plaintext highlighter-rouge">?.</code> 의 왼쪽에 null 혹은 undefined이면 undefined를 반환하고, 그렇지 않으면 오른쪽 프로퍼티 참조를 계속한다.</li>
</ul>

<p>논리곱 연산자 &amp;&amp;의 경우 왼쪽이 Falsy 값이면 왼쪽 값을 그대로 반환한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//논리곱 연산자 사용</span>
<span class="dl">""</span> <span class="o">&amp;&amp;</span> <span class="dl">""</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="c1">//''</span>
</code></pre></div></div>

<p>위의 경우 ‘‘.length는 0이 나와야 하는데, 빈 문자열이 Falsy 값이기 때문에 논리곱 연산자는 false로 판단해 왼쪽의 ‘‘를 반환하게 된다.</p>

<p>반면 옵셔널 체이닝 연산자인 <code class="language-plaintext highlighter-rouge">?.</code>는 왼쪽 값이 Falsy 값이라도 null이나 undefined가 아니면 참조가 가능하다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//옵셔널 체이닝 연산자 사용</span>
<span class="dl">""</span><span class="p">?.</span><span class="nx">length</span><span class="p">;</span> <span class="c1">// 0</span>
</code></pre></div></div>

<h2 id="null-병합-연산자">null 병합 연산자(??)</h2>

<ul>
  <li>ES11에서 도입되었다.</li>
  <li>왼쪽 피연산자가 null이나 undefined인 경우 오른쪽 피연산자를 반환한다.</li>
  <li>그렇지 않으면 왼쪽 피연산자를 반환한다.</li>
  <li>변수에 기본값을 설정할 때 유용하다.</li>
</ul>

<p>논리합 연산자 ||의 경우 왼쪽이 Falsy 값이면 오른쪽 값을 그대로 반환한다.
만약 0이나 ‘‘이 기본값이라면 생각한 대로 동작하지 않을 수 있다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">default</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 'default'</span>
</code></pre></div></div>

<p>반면 null 병합 연산자의 경우 왼쪽 값이 Falsy 값이어도 null이나 undefined가 아니라면 왼쪽 값을 반환한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">??</span> <span class="dl">"</span><span class="s2">default</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 0</span>
</code></pre></div></div>

<p class="notice--danger">deep dive 6장,9장 참고</p>]]></content><author><name>Reyna</name></author><category term="javascript" /><category term="javascript" /><category term="type" /><summary type="html"><![CDATA[type]]></summary></entry><entry><title type="html">[Deep Dive] 3. 변수</title><link href="http://localhost:4000/javascript/variable/" rel="alternate" type="text/html" title="[Deep Dive] 3. 변수" /><published>2023-02-22T00:00:00+09:00</published><updated>2023-02-24T00:00:00+09:00</updated><id>http://localhost:4000/javascript/variable</id><content type="html" xml:base="http://localhost:4000/javascript/variable/"><![CDATA[<h2 id="1-변수의-정의와-사용하는-이유">1. 변수의 정의와 사용하는 이유</h2>

<h3 id="변수의-의미">변수의 의미</h3>

<ul>
  <li>하나의 값을 저장하기 위해 확보한 메모리 공간 자체</li>
  <li>메모리 공간을 식별하기 위해 붙인 이름</li>
</ul>

<h3 id="변수를-사용하는-이유">변수를 사용하는 이유</h3>

<p>기억하고 싶은 값을 메모리에 저장하고, 그 값을 다시 참조해서 재사용하기 위해 변수라는 메커니즘을 사용한다.</p>

<h3 id="변수와-관련된-용어">변수와 관련된 용어</h3>

<ul>
  <li>변수 이름(변수명) <br />
메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름</li>
  <li>변수 값<br />
변수에 저장된 값</li>
  <li>할당(대입,저장)<br />
변수에 값을 저장하는 것</li>
  <li>참조<br />
변수에 저장된 값을 읽어들이는 것</li>
  <li>식별자<br />
어떤 값을 구별해서 식별할 수 있는 고유한 이름. 값이 저장된 메모리의 <strong>주소</strong>를 기억해서, 그 메모리에 저장된 값에 접근할 수 있다. 변수, 함수, 클래스 등의 이름은 모두 식별자이며, 선언을 통해 식별자임을 자바스크립트 엔진에 알려준다.</li>
</ul>

<h2 id="2-변수를-선언하는-방법">2. 변수를 선언하는 방법</h2>

<h3 id="변수-선언">변수 선언</h3>

<ul>
  <li>값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것</li>
</ul>

<h3 id="변수-선언-방법">변수 선언 방법</h3>

<ul>
  <li>var, let, const 키워드를 사용한다.<br />
(var의 단점을 보완하기 위해 let과 const 키워드가 ES6에서 추가되었다.<a href="https://sena-22.github.io/javascript/variable/#8-let-const-키워드">참고</a>)</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//변수 선언</span>
<span class="kd">let</span> <span class="nx">tomato</span><span class="p">;</span> <span class="c1">// let 키워드 + 변수 이름</span>
</code></pre></div></div>

<p class="notice--primary">키워드는 자바스크립트 엔진이 수행할 동작을 규정해놓은 명령어이다. 위에서는 let이 키워드이며, 뒤에 오는 변수 이름(여기서 tomato)으로 변수를 선언하라고 하는 것이다.</p>

<h3 id="변수가-선언되는-단계">변수가 선언되는 단계</h3>

<p>변수는 선언 단계와 초기화 단계를 거쳐 선언을 수행한다.</p>

<ul>
  <li>선언 단계 : 변수 이름을 자바스크립트 엔진에 알려준다.</li>
  <li>초기화 단계 : 메모리 공간을 확보하고, undefined를 할당해서 초기화한다.
초기화 단계를 거치지 않으면 확보한 메모리 공간에 예전 값이 남아 있을 수 있다.</li>
</ul>

<h2 id="3-값-할당--재할당하기">3. 값 할당 &amp; 재할당하기</h2>

<h3 id="변수에-값을-할당하는-방법">변수에 값을 할당하는 방법</h3>

<p>변수에 값을 할당할 때는 할당 연산자(=)를 사용해 오른쪽의 값을 왼쪽에 할당한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">tomato</span><span class="p">;</span>
<span class="nx">tomato</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>

<span class="c1">//선언과 할당을 동시에 할 수도 있다</span>
<span class="kd">let</span> <span class="nx">tomato</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="변수-선언과-값의-할당-시점">변수 선언과 값의 할당 시점</h3>

<ul>
  <li>변수 선언 : 코드가 실행되는 런타임 이전에 실행된다.</li>
  <li>값의 할당 : 코드가 실행되는 시점인 런타임에 실행된다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 변수 선언</span>
<span class="kd">let</span> <span class="nx">tomato</span><span class="p">;</span>

<span class="c1">// 선언은 되었지만 값이 할당되지 않아 undefined가 반환된다</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tomato</span><span class="p">);</span> <span class="c1">//undefined</span>

<span class="c1">// 값 할당</span>
<span class="nx">tomato</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>

<span class="c1">// 변수에 값이 할당되었으므로 변수에 저장된 값이 반환된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tomato</span><span class="p">);</span> <span class="c1">//800</span>
</code></pre></div></div>

<h3 id="값을-재할당할-때-생기는-일">값을 재할당할 때 생기는 일</h3>

<ul>
  <li>재할당은 이미 값이 할당된 변수에 새로운 값을 다시 할당하는 것이다</li>
  <li>변수는 선언과 동시에 undefined로 초기화되기 때문에, 처음으로 값을 할당하는 것도 사실 재할당이라고 할 수 있다.</li>
  <li>const 키워드로 선언한 변수는 할당과 동시에 초기화해야 하고, 재할당이 불가능하다(그래서 보통 변수가 아니라 상수를 선언하기 위해 사용한다. <a href="https://sena-22.github.io/javascript/variable/#const-키워드">아래</a>에서 더 자세히 알아볼 것이다)</li>
  <li>재할당할 때, 원래 있던 메모리 공간에 새로운 값을 덮어씌우는 것이 아니고, <mark>새로운 메모리 공간을 확보하고 그 공간에 값을 저장</mark>하는 방식으로 동작한다. 그 전에 사용하던 메모리 공간은 변수 이름과 연결이 끊어지므로 그 안에 들어있는 값 역시 참조할 수도 없고, 필요하지 않게 된다. 이런 값들은 가비지 콜렉터에 의해 메모리에서 해제된다.</li>
</ul>

<h2 id="4-식별자-네이밍-규칙">4. 식별자 네이밍 규칙</h2>

<h3 id="식별자-네이밍-규칙">식별자 네이밍 규칙</h3>

<ul>
  <li>특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.</li>
  <li>숫자로 시작할 수 없다.</li>
  <li>예약어는 사용할 수 없다.</li>
</ul>

<p>예약어는 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말한다.
javascript의 예약어는 await, break, continue, function, if 등이 있다.
<a href="https://www.w3schools.com/js/js_reserved.asp">javascript의 예약어</a></p>

<p>🧐 키워드와 예약어의 차이? <br />
키워드는 특정 목적을 수행하기 위해 쓰이는데, 예약어는 아직 쓰임새는 없지만 키워드로 쓸 가능성이 있어 예약해 둔 단어라고 한다. 언어마다 키워드와 예약어가 동일한 언어도 있고, 다른 언어도 있다.</p>

<h3 id="네이밍-컨벤션">네이밍 컨벤션</h3>

<p>하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성을 높이기 위해 규정한 명명 규칙이다.</p>

<h3 id="자주-사용되는-네이밍-컨벤션">자주 사용되는 네이밍 컨벤션</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 카멜 케이스</span>
<span class="kd">let</span> <span class="nx">firstName</span><span class="p">;</span> <span class="c1">//변수, 함수 이름에 자주 사용</span>

<span class="c1">// 스네이크 케이스</span>
<span class="kd">let</span> <span class="nx">frist_name</span><span class="p">;</span>

<span class="c1">// 파스칼 케이스</span>
<span class="kd">let</span> <span class="nx">FirstName</span><span class="p">;</span> <span class="c1">//생성자 함수, 클래스 이름에 자주 사용</span>

<span class="c1">// 헝가리안 케이스</span>
<span class="kd">let</span> <span class="nx">strFirstName</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">$elem</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="5-변수의-호이스팅">5. 변수의 호이스팅</h2>

<h3 id="변수-호이스팅의-의미">변수 호이스팅의 의미</h3>

<p>변수 호이스팅은 <strong>변수 선언문이 코드의 선두로 올려진 것처럼 동작하는 것</strong>을 말한다.
위에서 변수가 선언되는 시점이 런타임 이전이라고 했는데, 변수 호이스팅 때문에 그렇게 동작하는 것이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tomato</span><span class="p">);</span> <span class="c1">//undefined</span>

<span class="kd">var</span> <span class="nx">tomato</span><span class="p">;</span>
</code></pre></div></div>

<p>var로 선언한 변수의 경우 선언 이전에 참조해도 에러가 나지 않는다.</p>

<h3 id="var와-let의-변수-호이스팅">var와 let의 변수 호이스팅</h3>

<ul>
  <li>var로 선언한 변수의 경우 선언 이전에 참조해도 에러가 나지 않는다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tomato</span><span class="p">);</span> <span class="c1">//undefined</span>

<span class="kd">var</span> <span class="nx">tomato</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>반면 let으로 선언한 경우 선언 이전에 참조하면 참조 에러가 나타난다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tomato</span><span class="p">);</span> <span class="c1">//Uncaught ReferenceError: tomato is not defined</span>

<span class="kd">let</span> <span class="nx">tomato</span><span class="p">;</span>
</code></pre></div></div>

<p>let으로 선언한 변수가 호이스팅이 일어나지 않는 것은 아니다. 하지만 선언 단계와 초기화 단계가 한번에 진행되는 var 키워드와 달리, <mark>let 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리</mark>되어 진행된다. 선언 단계는 런타임 이전에 일어나지만, 초기화 단계는 선언문에 도달했을 때 실행된다. 따라서 선언 단계와 초기화 단계 사이에 변수를 참조할 수 없는 구간이 생기고, 이 구간을 <mark>일시적 사각지대(Temporal Dead Zone)</mark>라고 부른다.</p>

<h2 id="6-변수의-생명주기">6. 변수의 생명주기</h2>

<ul>
  <li>
    <p>변수는 생성되고 소멸되는 생명주기를 가진다.</p>
  </li>
  <li>
    <p>변수의 생명주기는 메모리 공간이 확보된 시점 ~ 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지이다.</p>
  </li>
  <li>
    <p>전역 변수의 생명 주기는 애플리케이션의 생명 주기와 일치하고, 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.</p>
  </li>
  <li>
    <p>전역 변수와 지역 변수의 호이스팅은 조금 다르다. 호이스팅이 스코프 단위로 일어나기 때문이다. 전역 변수의 경우 전역 스코프의 상위로 끌어올려진 것처럼 호이스팅되지만, 지역 변수의 경우 지역 스코프의 상위로 끌어올려진 것처럼 호이스팅된다.</p>
  </li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">global</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">con</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">//지역 스코프에서 a가 선언되었지만 초기화되지 않은 상태</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">local</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">con</span><span class="p">();</span> <span class="c1">//undefined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">//'global'</span>
</code></pre></div></div>

<h2 id="7-전역-변수의-문제점과-억제-방법">7. 전역 변수의 문제점과 억제 방법</h2>

<h3 id="1-암묵적-결합">1. 암묵적 결합</h3>

<p>암묵적 결합이란 모든 코드가 전역 변수를 참조하고 변경할 수 있도록 허용하는 것을 말하는데, 이는 코드의 가독성을 해치고 의도치 않은 상태 변경을 유발할 수 있다.</p>

<h3 id="2-긴-생명-주기">2. 긴 생명 주기</h3>

<p>전역 변수는 생명 주기가 길기 때문에 메모리도 오래 소비하고 변수의 이름이 중복될 가능성도 높아진다.</p>

<h3 id="3-스코프-체인-상에서-종점에-존재">3. 스코프 체인 상에서 종점에 존재</h3>

<p>변수를 찾을 때 전역 변수는 마지막에 검색하기 때문에 속도가 가장 느리다.</p>

<h3 id="4-네임스페이스-오염">4. 네임스페이스 오염</h3>

<p>파일이 분리되어 있어도 스코프를 공유하기 때문에 다른 파일에서 전역으로 명명된 변수가 있을 경우 문제가 발생할 수 있다.</p>

<h3 id="전역-변수의-사용을-억제하는-방법">전역 변수의 사용을 억제하는 방법</h3>

<ul>
  <li>즉시 실행 함수 : 즉시 실행 함수는 단 한 번만 호출되기 때문에 즉시 실행 함수에 감싸진 변수는 즉시 실행 함수의 지역 변수가 된다.</li>
  <li>네임스페이스 객체 : 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용할 변수를 프로퍼티로 추가하는 방법이다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">MYAPP</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">//전역 네임스페이스 객체</span>

<span class="nx">MYAPP</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">jack</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">MYAPP</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//'jack'</span>
</code></pre></div></div>

<ul>
  <li>이외에도 클로저를 기반으로 작동하는 모듈 패턴을 사용하거나, 전역 변수를 사용할 수 없게 만드는 ES6 모듈을 사용하는 방법도 있다.</li>
</ul>

<h2 id="8-let-const-키워드">8. let, const 키워드</h2>

<h3 id="var-키워드로-선언한-변수의-문제점">var 키워드로 선언한 변수의 문제점</h3>

<ul>
  <li>변수의 중복 선언 허용</li>
  <li>함수 레벨 스코프<br />
var 키워드로 선언한 변수는 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 if문이나 for문 안의 변수는 전역 변수가 되기 때문에 전역 변수가 남용되는 일이 일어날 수 있다.</li>
  <li>변수 호이스팅<br />
위에서 본 것처럼 선언과 초기화가 한번에 일어나 변수 선언문 이전에 참조가 가능하다.</li>
</ul>

<h3 id="let-키워드">let 키워드</h3>

<ul>
  <li>
    <p>변수 중복 선언 금지<br />
let으로 선언한 변수는 중복 선언이 불가능하다. (재할당은 가능하다)</p>
  </li>
  <li>블록 레벨 스코프 <br /> 함수 코드 블록만을 지역 스코프로 인정하는 var와 달리 let으로 선언한 변수는 if문이나 for문, while문 등 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.</li>
  <li>변수 호이스팅 <br />
변수의 선언과 초기화를 분리하여 일시적 사각 지대에서 참조할 경우 에러가 발생하여 마치 호이스팅이 일어나지 않는 것처럼 동작한다.</li>
</ul>

<h3 id="const-키워드">const 키워드</h3>

<ul>
  <li>선언과 초기화<br />
const로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">apple</span><span class="p">;</span> <span class="c1">//Uncaught SyntaxError: Missing initializer in const declaration</span>

<span class="kd">const</span> <span class="nx">apple</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>재할당 금지<br />
const로 선언한 변수는 재할당이 금지된다. 이 특징을 이용하여 const 키워드를 상수를 표현하는 데 사용하기도 한다. 고정된 값을 사용할 때 상수로 정의하여 사용하면 의미를 파악하기 쉬워진다. 일반적으로 상수를 선언할 때에는 대문자로 선언하고, 스네이크 케이스를 사용한다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">VAT</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c1">// 상수로 선언. 세율이 바뀌면 이 값만 조정하면 된다.</span>

<span class="kd">let</span> <span class="nx">preTaxPrice</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">//세전</span>

<span class="kd">let</span> <span class="nx">afterTaxPrice</span> <span class="o">=</span> <span class="nx">preTaxPrice</span> <span class="o">+</span> <span class="nx">preTaxPrice</span> <span class="o">*</span> <span class="nx">VAT</span><span class="p">;</span> <span class="c1">// 세후</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">afterTaxPrice</span><span class="p">);</span> <span class="c1">//110</span>
</code></pre></div></div>

<ul>
  <li>const 키워드와 객체<br />
const 키워드로 할당된 원시 값은 변경할 수 없지만, 객체는 값을 변경할 수 있다. 새로운 값을 재할당하는 것이 아니라 프로퍼티를 생성, 삭제, 수정하는 방법을 통해 변경할 수 있기 때문이다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">apple</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">price</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
<span class="p">};</span>

<span class="nx">apple</span><span class="p">.</span><span class="nx">price</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span> <span class="c1">//재할당 없이 변경</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">apple</span><span class="p">);</span> <span class="c1">// {price: 200}</span>
</code></pre></div></div>

<p>변수를 선언할 때에는 기본적으로 const를 사용하고, 재할당이 필요한 경우에 한정하여 let을 사용하는 방법이 가장 안전하다고 한다.</p>

<p class="notice--danger">deep dive 4장, 14장, 15장 참고</p>]]></content><author><name>Reyna</name></author><category term="javascript" /><category term="javascript" /><category term="variable" /><summary type="html"><![CDATA[variable]]></summary></entry><entry><title type="html">[Programmers] 8. 약수의 합 (javascript)</title><link href="http://localhost:4000/programmers/sum-of-divisor/" rel="alternate" type="text/html" title="[Programmers] 8. 약수의 합 (javascript)" /><published>2023-02-22T00:00:00+09:00</published><updated>2023-02-22T00:00:00+09:00</updated><id>http://localhost:4000/programmers/sum-of-divisor</id><content type="html" xml:base="http://localhost:4000/programmers/sum-of-divisor/"><![CDATA[<h2 id="-문제">🤔 문제</h2>

<p>정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.</p>

<h2 id="제한사항">제한사항</h2>

<ul>
  <li>n은 0 이상 3000이하인 정수입니다</li>
</ul>

<h2 id="입출력-예시">입출력 예시</h2>

<table>
  <thead>
    <tr>
      <th>maps</th>
      <th>answer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>12</td>
      <td>28</td>
    </tr>
    <tr>
      <td>5</td>
      <td>6</td>
    </tr>
  </tbody>
</table>

<h2 id="의사코드">의사코드</h2>

<blockquote>
  <p>해당 수를 나눈 나머지가 0이 되는 숫자가 약수
1부터 n까지 1씩 증가시키면서 n을 해당 수로 나눈 나머지가 0일 때만 더해준다.
더한 결과를 리턴한다.</p>
</blockquote>

<h2 id="제출한-답">제출한 답</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">%</span> <span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="notice--danger">💡 알고리즘 스터디 Recursive에서 공부한 내용 정리</p>]]></content><author><name>Reyna</name></author><category term="programmers" /><category term="study" /><category term="recursive" /><category term="javascript" /><category term="Lv.1" /><summary type="html"><![CDATA[약수의 합]]></summary></entry><entry><title type="html">[typescript] interface</title><link href="http://localhost:4000/typescript/interface/" rel="alternate" type="text/html" title="[typescript] interface" /><published>2023-02-21T00:00:00+09:00</published><updated>2023-02-21T00:00:00+09:00</updated><id>http://localhost:4000/typescript/interface</id><content type="html" xml:base="http://localhost:4000/typescript/interface/"><![CDATA[<p><strong>인터페이스</strong>는 객체의 타입을 정의하기 위해 사용된다.</p>

<h3 id="인터페이스-정의하기">인터페이스 정의하기</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Character</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="선택적-프로퍼티optional-properties-사용하기">선택적 프로퍼티(Optional Properties) 사용하기</h3>

<ul>
  <li>프로퍼티가 필수 사항이 아닐 때에는 <code class="language-plaintext highlighter-rouge">?</code>를 붙여 표시한다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Character</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">height</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span> <span class="c1">//키를 Optional Properties로 처리</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">character</span><span class="p">:</span> <span class="nx">Character</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Jack</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="c1">//height가 없어도 오류가 나지 않는다</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="읽기-전용-프로퍼티-사용하기">읽기 전용 프로퍼티 사용하기</h3>

<ul>
  <li>프로퍼티가 처음 생성될 때만 수정 가능하게 만들고 싶을 때에는 <code class="language-plaintext highlighter-rouge">readonly</code>를 앞에 붙여주면 된다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Character</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="k">readonly</span> <span class="nx">birthYear</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">character</span><span class="p">:</span> <span class="nx">Character</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Jack</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="na">birthYear</span><span class="p">:</span> <span class="mi">2000</span><span class="p">,</span> <span class="c1">// 이후 수정 불가능</span>
<span class="p">};</span>

<span class="nx">character</span><span class="p">.</span><span class="nx">birthYear</span> <span class="o">=</span> <span class="mi">1999</span><span class="p">;</span> <span class="c1">//readonly여서 에러가 발생한다.</span>
</code></pre></div></div>

<h3 id="문자열-인덱스-서명string-index-signatuer-추가하기">문자열 인덱스 서명(string index signatuer) 추가하기</h3>

<p>비슷한 타입의 프로퍼티를 여러 개 만들고 싶을 때는 <code class="language-plaintext highlighter-rouge">[키 이름:타입]:타입</code> 처럼 만들면 된다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Character</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="p">[</span><span class="nx">stat</span><span class="p">:</span> <span class="kr">number</span><span class="p">]:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">character</span><span class="p">:</span> <span class="nx">Character</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Jack</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">:</span> <span class="dl">"</span><span class="s2">HP</span><span class="dl">"</span><span class="p">,</span>
  <span class="mi">2</span><span class="p">:</span> <span class="dl">"</span><span class="s2">MP</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>위의 예시에서 stat 종류를 제한하고 싶을 때에는 <mark style="background-color: #ffdce0">문자열 리터럴 타입(String Literal Types)</mark>을 추가하면 된다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Stat</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">HP</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">MP</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">SP</span><span class="dl">'</span>

<span class="kr">interface</span> <span class="nx">Character</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="p">[</span><span class="nx">stat</span><span class="p">:</span> <span class="kr">number</span><span class="p">]:</span> <span class="nx">Stat</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="인터페이스로-클래스-정의하기">인터페이스로 클래스 정의하기</h3>

<p>클래스 선언문의 implements 뒤에 인터페이스를 선언하면 해당 클래스는 그 인터페이스를 반드시 구현해야 한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Character</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nx">start</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Wizard</span> <span class="k">implements</span> <span class="nx">Character</span> <span class="p">{</span>
  <span class="nx">name</span><span class="p">;</span>
  <span class="nx">age</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">c</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">start</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">start!</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Wizard</span><span class="p">(</span><span class="dl">"</span><span class="s2">jack</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">//Wizard: {"age": 20,"name": "jack"}</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span> <span class="c1">//  "start!"</span>
</code></pre></div></div>

<h3 id="인터페이스-확장하기">인터페이스 확장하기</h3>

<p><code class="language-plaintext highlighter-rouge">extends</code>를 사용하면 인터페이스를 확장할 수 있다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Car</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">wheels</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nx">start</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Toy</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Toycar</span> <span class="kd">extends</span> <span class="nx">Car</span><span class="p">,</span> <span class="nx">Toy</span> <span class="p">{</span>
  <span class="c1">// multiple-extends</span>
  <span class="nl">price</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="참고">참고</h3>

<p class="notice--primary"><a href="https://www.typescriptlang.org/static/TypeScript%20Interfaces-34f1ad12132fb463bd1dfe5b85c5b2e6.png">Typescript Cheat Sheet Interface</a> <br />
<a href="https://typescript-kr.github.io/pages/interfaces.html">Typescript handbook Interface</a> <br />
<a href="https://poiemaweb.com/typescript-interface">poiemaweb Interface</a></p>]]></content><author><name>Reyna</name></author><category term="typescript" /><category term="typescript" /><category term="interface" /><summary type="html"><![CDATA[interface]]></summary></entry></feed>