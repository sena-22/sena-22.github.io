<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[한입 크기로 잘라 먹는 리액트] 간단한 일기장 만들기 - Reyna</title>
<meta name="description" content="react">


  <meta name="author" content="Reyna">
  
  <meta property="article:author" content="Reyna">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Reyna">
<meta property="og:title" content="[한입 크기로 잘라 먹는 리액트] 간단한 일기장 만들기">
<meta property="og:url" content="http://localhost:4000/lecture/simple-diary/">


  <meta property="og:description" content="react">







  <meta property="article:published_time" content="2023-04-14T00:00:00+09:00">



  <meta property="article:modified_time" content="2023-04-15T00:00:00+09:00">



  

  


<link rel="canonical" href="http://localhost:4000/lecture/simple-diary/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Reyna",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Reyna Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
<link rel="manifest" href="/site.webmanifest" />
<meta name="msapplication-TileColor" content="#da532c" />
<meta name="theme-color" content="#ffffff" />

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Reyna
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://sena-22.github.io/">Home</a>
            </li><li class="masthead__menu-item">
              <a href="/categories">Category</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
           



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/" itemprop="item"><span itemprop="name">Home</span></a>

          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#lecture" itemprop="item"><span itemprop="name">Lecture</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        <li class="current">[한입 크기로 잘라 먹는 리액트] 간단한 일기장 만들기</li>
      
    
  </ol>
</nav>
  

<div id="main" role="main">
  
<div class="sticky sidebar">
  


<div itemscope itemtype="https://schema.org/Person" class="h-card">

  

  <div class="author__content">
    <h3 class="author__name p-name" itemprop="name">
      <a class="u-url" rel="me" href="http://localhost:4000/" itemprop="url">Reyna</a>
    </h3>
    
      <div class="author__bio p-note" itemprop="description">
        

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name" class="p-locality"></span>
        </li>
      

      
        
          
            <li><a href="https://github.com/sena-22" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer me">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>
   

<nav class="nav__list">
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc"></label>
  <ul class="nav__items" id="category_tag_menu">
    <!--전체 글 수-->
    <li>
      <span style="font-family:'Nanum Gothic Coding'">All Posts</style> <span style="font-family:'Nanum Gothic Coding'">(120)</style> 
    </li>
    <li>
      <!--span 태그로 카테고리들을 크게 분류 ex)javascript-->
      <span class="nav__sub-title">JS/TS</span>
      <!--ul 태그로 같은 카테고리들 모아둔 페이지들 나열-->
      <ul>
        <!--javascript 카테고리 글들을 모아둔 페이지인 /categories/javascript 주소의 글로 링크 연결-->
        <!--category[1].size 로 해당 카테고리를 가진 글의 개수 표시-->
                           
        <li>
          <a href="/categories/javascript" class=""
            >Javascript (16)</a
          >
        </li>
                 
      </ul>
      <ul>
                       
        <li>
          <a href="/categories/typescript" class=""
            >Typescript (7)</a
          >
        </li>
                     
      </ul>
      <ul>
                                    
      </ul>
      <span class="nav__sub-title">React</span>
      <ul>
                             
        <li>
          <a href="/categories/react" class=""
            >React (1)</a
          >
        </li>
               
      </ul>
      <ul>
                                    
      </ul>
      <span class="nav__sub-title">HTML & CSS </span>
      <ul>
         
        <li>
          <a href="/categories/html" class="">HTML (3)</a>
        </li>
                                   
      </ul>
      <ul>
                   
        <li>
          <a href="/categories/css" class="">CSS (6)</a>
        </li>
                         
      </ul> 
      <span class="nav__sub-title">Project</span>
      <ul>
                 
        <li>
          <a href="/categories/main-project" class="">Main Project (8)</a>
        </li>
                           
      </ul>
      <ul>
                     
        <li>
          <a href="/categories/mini-project" class="">Mini Project (12)</a>
        </li>
                       
      </ul>
      <span class="nav__sub-title">Algorithm</span>
      <ul>
           
        <li>
          <a href="/categories/algorithm" class=""
            >Algorithm (5)</a
          >
        </li>
                                 
      </ul>
      <ul>
             
        <li>
          <a href="/categories/programmers" class=""
            >Programmers (29)</a
          >
        </li>
                               
      </ul>
         <ul>
                                 
        <li>
          <a href="/categories/baekjoon" class=""
            >Baekjoon (5)</a
          >
        </li>
           
      </ul>
      <span class="nav__sub-title">ETC</span>
        <ul>
                                   
        <li>
          <a href="/categories/lecture" class="">Lecture (10)</a>
        </li>
         
      </ul>
      <ul>
      <ul>
               
        <li>
          <a href="/categories/blog" class="">Blog (3)</a>
        </li>
                             
      </ul>
      <ul>
                                    
      </ul>
      <ul>
                         
        <li>
          <a href="/categories/notes" class=""
            >Notes (8)</a
          >
        </li>
                   
      </ul>
    </li>
  </ul>
</nav>
 
</div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta
      itemprop="headline"
      content="[한입 크기로 잘라 먹는 리액트] 간단한 일기장 만들기"
    /> <meta
      itemprop="description"
      content="react"
    /> <meta
      itemprop="datePublished"
      content="2023-04-14T00:00:00+09:00"
    /> <meta
      itemprop="dateModified"
      content="2023-04-15T00:00:00+09:00"
    />

    <div class="page__inner-wrap">
      
      <header>
        
        <h1 id="page-title" class="page__title" itemprop="headline">
          <p>[한입 크기로 잘라 먹는 리액트] 간단한 일기장 만들기</p>

        </h1>
         
        <p class="page__meta">
          <strong
            ><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Date:</strong
          >
          <time datetime="2023-04-14T00:00:00+09:00"
            >2023.04.14</time
          >&nbsp&nbsp&nbsp<strong
            ><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong
          >
          <time datetime="2023-04-15"
            >2023.04.15</time
          >
        </p>
          


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#lecture" class="page__taxonomy-item p-category" rel="tag">lecture</a>
    
    </span>
  </p>



  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#react" class="page__taxonomy-item p-category" rel="tag">react</a><span class="sep">, </span>
    
      <a href="/tags/#udemy" class="page__taxonomy-item p-category" rel="tag">udemy</a><span class="sep">, </span>
    
      <a href="/tags/#usecallback" class="page__taxonomy-item p-category" rel="tag">useCallback</a><span class="sep">, </span>
    
      <a href="/tags/#usememo" class="page__taxonomy-item p-category" rel="tag">useMemo</a><span class="sep">, </span>
    
      <a href="/tags/#usereducer" class="page__taxonomy-item p-category" rel="tag">useReducer</a>
    
    </span>
  </p>
 
      </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <aside class="sidebar__right sticky">
          <nav class="toc">
            <header>
              <h4 class="nav__title">
                <i class="fas fa-file-alt"></i>
                Index
              </h4>
            </header>
            <ul class="toc__menu"><li><a href="#diary-editor-컴포넌트">Diary Editor 컴포넌트</a><ul><li><a href="#여러가지-상태를-한번에-관리하기">여러가지 상태를 한번에 관리하기</a></li><li><a href="#useref를-이용하여-원하는-요소에-포커싱-하기">useRef를 이용하여 원하는 요소에 포커싱 하기</a></li></ul></li><li><a href="#diary-list--diary-item-컴포넌트">Diary List &amp; Diary Item 컴포넌트</a><ul><li><a href="#배열을-이용하여-리스트-렌더링하기">배열을 이용하여 리스트 렌더링하기</a></li><li><a href="#state-끌어올리기">state 끌어올리기</a></li></ul></li><li><a href="#리액트의-라이프-사이클-제어하기">리액트의 라이프 사이클 제어하기</a></li><li><a href="#리액트에서-api-호출해서-일기의-초기값-만들어주기">리액트에서 API 호출해서 일기의 초기값 만들어주기</a></li><li><a href="#최적화">최적화</a><ul><li><a href="#usememo를-이용해서-연산-결과-재사용하기">useMemo를 이용해서 연산 결과 재사용하기</a></li><li><a href="#reactmemo를-이용해서-컴포넌트-재사용하기">React.memo를 이용해서 컴포넌트 재사용하기</a><ul><li><a href="#예시-1">예시 1</a></li><li><a href="#예시-2">예시 2</a></li></ul></li><li><a href="#usecallback으로-함수-최적화하기">useCallback으로 함수 최적화하기</a></li></ul></li><li><a href="#usereducer를-이용하여-복잡한-상태-분리하기">useReducer를 이용하여 복잡한 상태 분리하기</a></li><li><a href="#context로-컴포넌트-트리에-전역으로-데이터-공급하기">context로 컴포넌트 트리에 전역으로 데이터 공급하기</a><ul><li><a href="#context-생성">context 생성</a></li><li><a href="#context-provier를-이용해서-데이터-공급하기">Context Provier를 이용해서 데이터 공급하기</a></li><li><a href="#하위-컴포넌트에서-데이터를-가져와서-사용하기">하위 컴포넌트에서 데이터를 가져와서 사용하기</a></li><li><a href="#context-중첩해서-사용하기">context 중첩해서 사용하기</a></li></ul></li></ul>

          </nav>
        </aside>
         <p><img src="https://user-images.githubusercontent.com/110877564/232182349-7039b316-9092-4f39-b2aa-752e54e9aeb7.png" alt="제목을-입력해주세요_-004" /></p>

<p>섹션 6에서는 간단한 일기장을 만들어보았다.</p>

<p><br /></p>

<p><img width="1520" alt="스크린샷 2023-04-14 오후 7 48 00" src="https://user-images.githubusercontent.com/110877564/232024604-e33e6bae-0ede-4d64-92be-23dca9f8a2c6.png" /></p>

<p>일기장은 총 세 영역으로 나누어진다. 첫 번째가 일기를 작성할 수 있는 에디터 영역, 두 번째는 일기의 메타 정보를 보여주는 영역, 마지막이 일기를 보여주는 리스트 영역이다.</p>

<p><br /></p>

<h1 id="diary-editor-컴포넌트">Diary Editor 컴포넌트</h1>

<p><img width="556" alt="스크린샷 2023-04-14 오후 7 56 15" src="https://user-images.githubusercontent.com/110877564/232026257-c937b3c4-5d34-4168-8008-ab8fd6a96b7a.png" /></p>

<h2 id="여러가지-상태를-한번에-관리하기">여러가지 상태를 한번에 관리하기</h2>

<p>다이어리 에디터는 작성자, 일기 본문, 감정 점수 세 개의 입력값을 필요로 한다. 각각 <code class="language-plaintext highlighter-rouge">input</code>, <code class="language-plaintext highlighter-rouge">textarea</code>, <code class="language-plaintext highlighter-rouge">select &amp; option</code> 태그를 이용하는데, 이 입력값은 하나의 상태로 관리할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">state</span><span class="p">,</span> <span class="nx">setState</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">({</span>
  <span class="na">author</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span>
  <span class="na">content</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span>
  <span class="na">emotion</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span>
<span class="p">})</span>

<span class="kd">const</span> <span class="nx">handleChangeState</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setState</span><span class="p">({</span>
    <span class="p">...</span><span class="nx">state</span><span class="p">,</span> <span class="c1">//spread 연산자</span>
    <span class="p">[</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">]:</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="c1">//해당 값만 바꿔준다</span>
  <span class="p">})</span>
<span class="p">}</span>

 <span class="k">return</span><span class="p">(</span>
  <span class="p">...</span>
  <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">name</span><span class="o">=</span><span class="dl">"</span><span class="s2">author</span><span class="dl">"</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">state</span><span class="p">.</span><span class="nx">author</span><span class="p">}</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">handleChangeState</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>  <span class="c1">//textare와 select 태그도 같은 방식으로 만들어준다.</span>
  <span class="p">...</span>
 <span class="p">)</span>
</code></pre></div></div>

<h2 id="useref를-이용하여-원하는-요소에-포커싱-하기">useRef를 이용하여 원하는 요소에 포커싱 하기</h2>

<p>일기 저장 버튼을 눌렀을 때, 저자 혹은 일기의 내용이 원하는 값 이상으로 입력되지 않았을 때 useRef를 이용하여 포커싱을 할 수 있다. useRef()는 DOM 요소를 조작할 수 있는 리액트 훅으로 ref는 레퍼런스, 즉 참조를 의미한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">authorInput</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">()</span>
</code></pre></div></div>

<p>먼저 useRef를 호출한 뒤에 그 반환값을 상수에 담아주었다. 이 상수에는 <code class="language-plaintext highlighter-rouge">React.MutableRefObject</code>가 담기게 되는데, <code class="language-plaintext highlighter-rouge">MutableRefObject</code>는 DOM 요소를 저장하고 관리할 수 있는 기능을 가지고 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">input</span>
  <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">authorInput</span><span class="p">}</span>
  <span class="nx">name</span><span class="o">=</span><span class="dl">"</span><span class="s2">author</span><span class="dl">"</span>
  <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">state</span><span class="p">.</span><span class="nx">author</span><span class="p">}</span>
  <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">handleChangeState</span><span class="p">}</span>
<span class="sr">/</span><span class="err">&gt;
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">input</code>에 <code class="language-plaintext highlighter-rouge">ref</code> 속성을 통해 <code class="language-plaintext highlighter-rouge">authorInput</code>를 할당해준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">author</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">authorInput</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">focus</span><span class="p">()</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="c1">//조건을 만족했을 경우 제출</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">authorInput</code>가 는 현재 가리키고 있는 <code class="language-plaintext highlighter-rouge">input</code> 요소를 <code class="language-plaintext highlighter-rouge">current</code> 속성을 통해 조작할 수 있다. (<code class="language-plaintext highlighter-rouge">current</code> 속성은 <code class="language-plaintext highlighter-rouge">MutableRefObject</code>의 속성 중 하나로, 현재 참조하고 있는 DOM 요소를 가리키는 역할을 한다.)</p>

<p><br /></p>

<h1 id="diary-list--diary-item-컴포넌트">Diary List &amp; Diary Item 컴포넌트</h1>

<p><img width="1086" alt="스크린샷 2023-04-14 오후 8 41 07" src="https://user-images.githubusercontent.com/110877564/232034365-93ab6816-3ab6-4500-97f8-6026e10a3487.png" /></p>

<h2 id="배열을-이용하여-리스트-렌더링하기">배열을 이용하여 리스트 렌더링하기</h2>

<p>다이어리 리스트에서 각각의 일기는 내용만 다르고 구조는 똑같이 생겼다. 만약 일기를 모두 HTML 요소로 나열한다면 중복되는 코드가 계속 늘어날 것이다. 하지만 다이어리 아이템이라는 컴포넌트를 하나 만들어서 반복문을 돌려주면 하나의 컴포넌트로 수많은 일기들을 나타낼 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">diaryList</span> <span class="o">=</span> <span class="cm">/* 일기 데이터 */</span>
</code></pre></div></div>

<p>먼저 다이어리 리스트를 불러온다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
  <span class="p">{</span><span class="nx">diaryList</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">diary</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">DiaryItem</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">diary</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span> <span class="p">{...</span><span class="nx">diary</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">))}</span>
<span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div></div>

<p>map 함수를 이용하여 일기 정보를 하나씩 전달하고, 그 정보를 이용하여 만들어진 <code class="language-plaintext highlighter-rouge">&lt;DiaryItem&gt;</code>가 일기 리스트의 개수만큼 반복되며 반환된다. 그러면 각각의 다이어리가 담긴 배열이 완성되어 렌더링되는 것이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">DiaryItem</span> <span class="o">=</span> <span class="p">({</span><span class="nx">author</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">created_date</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">,</span> <span class="nx">id</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;DiaryList&gt;</code>에서 내려준 <code class="language-plaintext highlighter-rouge">...diary</code>는 이렇게 props로 받아와서 사용하면 된다.</p>

<h2 id="state-끌어올리기">state 끌어올리기</h2>

<p><img width="1174" alt="스크린샷 2023-04-14 오후 9 04 31" src="https://user-images.githubusercontent.com/110877564/232038763-85afaebe-1098-4410-8b04-b21d0fd97909.png" /></p>

<p>리액트에서 데이터는 위에서 아래로 흐른다. 위의 그림처럼 상위 컴포넌트인 App에서 데이터를 관리하고, 다이어리 에디터나 리스트는 그 데이터를 내려받아서 사용한다.
그런데 이 데이터를 바꾸는 일은 하위 컴포넌트에서 발생한다. 여기서는 다이어리 에디터에서 일기를 추가하고 있는데, 이는 이벤트가 밑에서 위로 올라감을 의미한다. 이때 <code class="language-plaintext highlighter-rouge">setData</code> 처럼 상위 컴포넌트에서 상태를 변경하는 함수 자체를 하위 컴포넌트로 전달하고, 이 함수를 하위 컴포넌트에서 실행하여 상태가 변하는 것을 상태 끌어올리기라고 한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//App.js</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">setData</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">([])</span>

<span class="kd">const</span> <span class="nx">onCreate</span> <span class="o">=</span> <span class="p">(</span><span class="nx">author</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">newItem</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">author</span><span class="p">,</span>
    <span class="nx">content</span><span class="p">,</span>
    <span class="nx">emotion</span><span class="p">,</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="nx">setData</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">[</span><span class="nx">newItem</span><span class="p">,...</span><span class="nx">data</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런 식으로 상위 컴포넌트인 App 컴포넌트에 데이터를 두고, 상태를 변경할 수 있는 함수인 <code class="language-plaintext highlighter-rouge">onCreate()</code>를 하위 컴포넌트에 props로 내려준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//App.js</span>
<span class="o">&lt;</span><span class="nx">DiaryEditor</span> <span class="nx">onCreate</span><span class="o">=</span><span class="p">{</span><span class="nx">onCreate</span><span class="p">}</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;DiaryEditor&gt;</code>에서는 함수를 내려받아서 사용하면, 상위 컴포넌트의 상태를 바꿀 수 있게 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//DiaryEditor.js</span>

<span class="kd">const</span> <span class="nx">DiaryEditor</span> <span class="o">=</span> <span class="p">({</span><span class="nx">onCreate</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">//글자수 조건 만족 시 onCreate 함수 실행</span>
    <span class="nx">onCreate</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">author</span><span class="p">,</span> <span class="nx">state</span><span class="p">.</span><span class="nx">content</span><span class="p">,</span> <span class="nx">state</span><span class="p">.</span><span class="nx">emotion</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 data에 일기가 추가되면, 다시 그 데이터를 받아 다이어리 리스트에 반영이 되게 된다.</p>

<p><br /></p>

<h1 id="리액트의-라이프-사이클-제어하기">리액트의 라이프 사이클 제어하기</h1>

<p><img width="1274" alt="스크린샷 2023-04-14 오후 9 35 10" src="https://user-images.githubusercontent.com/110877564/232044918-77eb82cb-bbef-48cc-94ea-738aa235d4b7.png" /></p>

<p>리액트는 탄생, 변화, 죽음이라는 세 개의 생애 주기를 가진다. 함수형 컴포넌트에서 생애 주기를 제어하기 위해서는 useEffect 훅을 사용하면 된다.</p>

<p>useEffect는 두 개의 인자를 받는다.</p>

<p>첫 번째는 실행하게 될 콜백 함수이며, 두 번째는 의존성 배열이라는 것이다. 의존성 배열은 콜백 함수가 실행되는 조건을 제어할 수 있다. 즉 이 배열에 넣어둔 값이 변화하면 콜백 함수가 다시 실행된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Mount!</span><span class="dl">"</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">//언마운트 시점에 실행</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Unmount!</span><span class="dl">"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="p">[])</span> <span class="c1">// 빈 배열을 넣으면 컴포넌트가 마운트 될 때 한 번만 실행</span>

<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">count가 5를 넘었습니다 따라서 1로 초기화합니다</span><span class="dl">"</span><span class="p">)</span>
    <span class="nx">setCount</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">count</span><span class="p">])</span> <span class="c1">//count 값이 변할 때마다 실행</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="리액트에서-api-호출해서-일기의-초기값-만들어주기">리액트에서 API 호출해서 일기의 초기값 만들어주기</h1>

<p><code class="language-plaintext highlighter-rouge">jsonplaceholder</code>는 더미 데이터를 api 호출로 얻을 수 있는 서비스이다.</p>

<p class="notice--primary"><a href="https://jsonplaceholder.typicode.com/">jsonplaceholder</a></p>

<p><code class="language-plaintext highlighter-rouge">fetch()</code>라는 내장 함수를 이용하면 인자로 전달한 url로 요청을 보낼 수 있다. 응답으로 받은 결과를 <code class="language-plaintext highlighter-rouge">res</code>에 담는 함수를 만들어준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getData</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://jsonplaceholder.typicode.com/comments</span><span class="dl">"</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">useEffect()</code>를 이용하면 App 컴포넌트가 마운트 될 때 <code class="language-plaintext highlighter-rouge">getData()</code>를 호출해서 요청을 보낼 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">getData</span><span class="p">()</span>
<span class="p">},</span> <span class="p">[])</span>
</code></pre></div></div>

<p>이 결과를 일기 데이터의 기초 데이터로 사용하기 위해 필요한 정보로 가공해준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">initData</span> <span class="o">=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">it</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">author</span><span class="p">:</span> <span class="nx">it</span><span class="p">.</span><span class="nx">email</span><span class="p">,</span>
    <span class="na">content</span><span class="p">:</span> <span class="nx">it</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span>
    <span class="na">emotion</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">//1~5 랜덤 난수 생성</span>
    <span class="na">created_date</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">(),</span>
    <span class="na">id</span><span class="p">:</span> <span class="nx">dataId</span><span class="p">.</span><span class="nx">current</span><span class="o">++</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<p>가공한 정보를 <code class="language-plaintext highlighter-rouge">setData</code>를 이용하여 data에 담아주면 App 컴포넌트가 마운트될 때 초기값으로 불러온 데이터가 들어가게 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setData</span><span class="p">(</span><span class="nx">initData</span><span class="p">)</span>
</code></pre></div></div>

<p>이 코드들을 합쳐주면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//App.js</span>
<span class="kd">const</span> <span class="nx">getData</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://jsonplaceholder.typicode.com/comments</span><span class="dl">"</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
  <span class="p">)</span>

  <span class="kd">const</span> <span class="nx">initData</span> <span class="o">=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">it</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">author</span><span class="p">:</span> <span class="nx">it</span><span class="p">.</span><span class="nx">email</span><span class="p">,</span>
      <span class="na">content</span><span class="p">:</span> <span class="nx">it</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span>
      <span class="na">emotion</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">//1~5 랜덤 난수 생성</span>
      <span class="na">created_date</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">(),</span>
      <span class="na">id</span><span class="p">:</span> <span class="nx">dataId</span><span class="p">.</span><span class="nx">current</span><span class="o">++</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">})</span>

  <span class="nx">setData</span><span class="p">(</span><span class="nx">initData</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="최적화">최적화</h1>

<h2 id="usememo를-이용해서-연산-결과-재사용하기">useMemo를 이용해서 연산 결과 재사용하기</h2>

<p><img width="1020" alt="스크린샷 2023-04-15 오전 5 42 38" src="https://user-images.githubusercontent.com/110877564/232150924-b7bf9af4-fbc9-4a6d-9fdf-a7ed26f494cd.png" /></p>

<p>메모이제이션을 이용하면 복잡한 연산을 다시 하지 않아도 된다는 장점이 있다.</p>

<p>리액트에서는 useMemo를 통해 메모이제이션을 활용할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//App.js</span>

<span class="cm">/* 감정 점수를 분석하는 함수 */</span>
<span class="kd">const</span> <span class="nx">getDiaryAnalysis</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">goodCount</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">it</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">emotion</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">).</span><span class="nx">length</span>
  <span class="kd">const</span> <span class="nx">badCount</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">goodCount</span>
  <span class="kd">const</span> <span class="nx">goodRatio</span> <span class="o">=</span> <span class="p">(</span><span class="nx">goodCount</span> <span class="o">/</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">goodCount</span><span class="p">,</span> <span class="nx">badCount</span><span class="p">,</span> <span class="nx">goodRatio</span><span class="p">}</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">]</span>
</code></pre></div></div>

<p><img width="946" alt="스크린샷 2023-04-15 오전 5 57 35" src="https://user-images.githubusercontent.com/110877564/232153319-4e2582cb-9667-493d-a62c-0c9355b71969.png" /></p>

<p>여기서 만든 일기장의 경우 감정 점수를 수정할 수 있는 기능이 없다. 따라서 수정이 가능한 건 내용 뿐이고, 위에서 만든 <code class="language-plaintext highlighter-rouge">getDiaryAnalysis()</code> 함수는 일기가 추가/삭제되는 등 일기 리스트의 길이가 변할 때만 작동하면 된다. 여기서 useMemo를 사용하면 언제 다시 계산할 지 정해줄 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//App.js</span>

<span class="cm">/* 메모이제이션 하고 싶은 함수를 useMemo로 감싸준다. */</span>
<span class="kd">const</span> <span class="nx">getDiaryAnalysis</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">goodCount</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">it</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">emotion</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">).</span><span class="nx">length</span>
  <span class="kd">const</span> <span class="nx">badCount</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">goodCount</span>
  <span class="kd">const</span> <span class="nx">goodRatio</span> <span class="o">=</span> <span class="p">(</span><span class="nx">goodCount</span> <span class="o">/</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">goodCount</span><span class="p">,</span> <span class="nx">badCount</span><span class="p">,</span> <span class="nx">goodRatio</span><span class="p">}</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">])</span>
</code></pre></div></div>

<p>이때 주의해야하는 점은 useMemo로 감싼 함수는 함수가 아니라 값을 리턴받기 때문에, 사용할 때 함수처럼 사용하면 에러가 발생한다. 따라서 값을 사용하는 것처럼 바꿔주어야 한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span><span class="nx">goodCount</span><span class="p">,</span> <span class="nx">badCount</span><span class="p">,</span> <span class="nx">goodRatio</span><span class="p">}</span> <span class="o">=</span> <span class="nx">getDiaryAnalysis</span><span class="p">()</span> <span class="c1">//error</span>

<span class="c1">//useMemo를 사용하였으므로 함수(getDiaryAnalysis())가 아니라 값 getDiaryAnalysis으로 사용한다.</span>
<span class="kd">const</span> <span class="p">{</span><span class="nx">goodCount</span><span class="p">,</span> <span class="nx">badCount</span><span class="p">,</span> <span class="nx">goodRatio</span><span class="p">}</span> <span class="o">=</span> <span class="nx">getDiaryAnalysis</span>
</code></pre></div></div>

<p class="notice--primary">💡 메모이제이션은 오히려 앱의 성능을 저하시킬 수 있기 때문에 남용하면 좋지 않다고 한다.
(<a href="https://velog.io/@lky5697/stop-using-usememo-now?utm_source=substack&amp;utm_medium=email">참고</a>)</p>

<h2 id="reactmemo를-이용해서-컴포넌트-재사용하기">React.memo를 이용해서 컴포넌트 재사용하기</h2>

<p>리액트에서 부모 컴포넌트가 리렌더링 되면, 자식 컴포넌트도 리렌더링 된다. 따라서 형제 컴포넌트에 어떤 일이 발생해서 부모 컴포넌트의 상태가 바뀌는 경우, 다른 형제의 컴포넌트는 그 상태를 사용하지 않아 리렌더링 될 필요가 없음에도 불구하고 리렌더되는 현상이 발생한다. 이때 React.memo를 이용하여 컴포넌트에 업데이트 조건을 걸어서 조건을 만족할 때만 리렌더링 되도록 할 수 있다.</p>

<p><a href="https://ko.reactjs.org/docs/react-api.html#reactmemo">공식 문서</a>에 따르면, React.memo는 고차 컴포넌트(HOC)이다. 고차 컴포넌트는 컴포넌트를 가져와 새 컴포넌트를 반환하는 함수이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">좋아진컴포넌트</span> <span class="o">=</span> <span class="nx">고차함수</span><span class="p">(</span><span class="nx">컴포넌트</span><span class="p">)</span>
</code></pre></div></div>

<p>React.memo도 이렇게 매개변수로 컴포넌트를 전달하면, 전달 받은 props가 동일한 결과를 나타낸다면 다시 계산하지 않고 리렌더링도 일어나지 않도록 할 수 있다.</p>

<h3 id="예시-1">예시 1</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">TextView</span> <span class="o">=</span> <span class="p">({</span><span class="nx">text</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Update :: Text : </span><span class="p">${</span><span class="nx">text</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">}</span>

<span class="kd">const</span> <span class="nx">CountView</span> <span class="o">=</span> <span class="p">({</span><span class="nx">count</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Update :: Count : </span><span class="p">${</span><span class="nx">count</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">}</span>
</code></pre></div></div>

<p>렌더링 될 때마다 console에 표시가 되는 컴포넌트를 만들었다. 이 컴포넌트들을 상위 컴포넌트에서 불러서 사용을 해보자.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">text</span><span class="p">,</span> <span class="nx">setText</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="dl">""</span><span class="p">)</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">App</span><span class="dl">"</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">count</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">CountView</span> <span class="nx">count</span><span class="o">=</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span><span class="o">&gt;</span>
          <span class="o">+</span>
        <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">text</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">TextView</span> <span class="nx">text</span><span class="o">=</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">setText</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">)}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>App 컴포넌트에서 버튼을 클릭하면 text는 상태가 그대로인데도 <code class="language-plaintext highlighter-rouge">&lt;TextView&gt;</code> 컴포넌트가 다시 렌더링되면서 console이 찍히는 것을 확인할 수 있다. 또 text를 바꾸었을 때도 count는 2인데 계속 렌더링되고 있다.</p>

<p><img width="256" alt="스크린샷 2023-04-15 오전 9 45 40" src="https://user-images.githubusercontent.com/110877564/232174748-a95ca3fe-913f-4434-ab8f-0d392545ab07.png" /></p>

<p>이제 이 컴포넌트들을 React.memo로 감싸보자.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">TextView</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(({</span><span class="nx">text</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Update :: Text : </span><span class="p">${</span><span class="nx">text</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">})</span>

<span class="kd">const</span> <span class="nx">CountView</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(({</span><span class="nx">count</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Update :: Count : </span><span class="p">${</span><span class="nx">count</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">})</span>
</code></pre></div></div>

<p>이렇게 바꿔주면 각자 인자로 들어온 값이 바뀌지 않으면 재계산하지 않게 된다.</p>

<p><img width="258" alt="스크린샷 2023-04-15 오전 9 48 49" src="https://user-images.githubusercontent.com/110877564/232174872-ab13f181-d7a1-4ba3-903d-3c9221e500bb.png" /></p>

<h3 id="예시-2">예시 2</h3>

<p>다른 예도 살펴보자.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">CounterA</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(({</span><span class="nx">count</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`CounterA Update - count : </span><span class="p">${</span><span class="nx">count</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">})</span>

<span class="kd">const</span> <span class="nx">CounterB</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(({</span><span class="nx">obj</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`CounterB Update - count : </span><span class="p">${</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">})</span>

<span class="kd">const</span> <span class="nx">OptimizeTest</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">setObj</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">({</span>
    <span class="na">count</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">style</span><span class="o">=&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">Counter</span> <span class="nx">A</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">CounterA</span> <span class="nx">count</span><span class="o">=</span><span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&gt;&lt;</span><span class="sr">/CounterA</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">A</span> <span class="nx">BUTTON</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">Counter</span> <span class="nx">B</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">CounterB</span> <span class="nx">obj</span><span class="o">=</span><span class="p">{</span><span class="nx">obj</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setObj</span><span class="p">({</span><span class="na">count</span><span class="p">:</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">})}</span><span class="o">&gt;</span><span class="nx">B</span> <span class="nx">BUTTON</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">OptimizeTest</span>
</code></pre></div></div>

<p>아까처럼 두 개의 컴포넌트를 만들고 React.memo로 감싼 뒤 상위 컴포넌트에서 불러와서 사용해보았다. 다른 점은 버튼을 클릭해도 같은 결과를 리턴하고, Counter B 같은 경우 객체 형태라는 것이다.
버튼을 클릭했을 때, Counter A는 예상대로 동작한다. 즉 count가 바뀌지 않기 때문에 리렌더링 되지 않고, 콘솔 창에 아무것도 나타나지 않는다. 하지만 B 버튼을 누르면 obj의 count가 바뀌지 않음에도 리렌더링 된다. 이건 객체를 비교할 때, 얕은 비교를 하기 때문이다.</p>

<p>얕은 비교는 객체를 값이 아니라 주소를 기준으로 비교하는 것이다.</p>

<p><img width="1314" alt="스크린샷 2023-04-15 오전 10 27 15" src="https://user-images.githubusercontent.com/110877564/232176589-7335d630-0fe0-4f27-b574-0dc143ac2ac3.png" /></p>

<p>위의 그림처럼 a 객체와 b 객체는 선언될 때 다른 주소에 저장된다. 따라서 값은 같더라도, 주소가 다르기 때문에 비교했을 때 false가 나온다.</p>

<p><img width="1314" alt="스크린샷 2023-04-15 오전 10 30 53" src="https://user-images.githubusercontent.com/110877564/232176735-70f3c216-294d-4e79-b30b-4bee71afceaf.png" /></p>

<p>한편 a를 선언한 후에 b에 직접 할당할 경우, 둘은 같은 주소를 가지게 된다. 따라서 비교했을 때 true가 나온다.</p>

<p>여기서 B 버튼을 클릭했을 때, <code class="language-plaintext highlighter-rouge">setObj({count: obj.count})</code>가 실행되면서 새로운 객체 <code class="language-plaintext highlighter-rouge">{count: obj.count}</code>가 생성되어 obj가 변경되고, 이전 상태의 obj와 새로운 obj는 얕은 비교를 수행해서 값은 다르지만 주소가 다르기 때문에 다르다고 판단되어 <code class="language-plaintext highlighter-rouge">&lt;CounterB&gt;</code> 컴포넌트가 다시 렌더링된다.</p>

<p>이런 현상을 방지하기 위해 React.memo에 두 번째 인자로, <code class="language-plaintext highlighter-rouge">areEqual()</code>이라는 함수를 사용할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//React.memo를 없애주었다</span>
<span class="kd">const</span> <span class="nx">CounterB</span> <span class="o">=</span> <span class="p">({</span><span class="nx">obj</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`CounterB Update - count : </span><span class="p">${</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">}</span>

<span class="kd">const</span> <span class="nx">areEqual</span> <span class="o">=</span> <span class="p">(</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">prev</span><span class="p">.</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span> <span class="o">===</span> <span class="nx">next</span><span class="p">.</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span> <span class="c1">//이전 props 현재 props가 같으면 리렌더링 하지 않음</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">MemoisedCouanterB</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(</span><span class="nx">CounterB</span><span class="p">,</span> <span class="nx">areEqual</span><span class="p">)</span> <span class="c1">//컴포넌트를 반환하는 고차 컴포넌트</span>

<span class="c1">//return</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">Counter</span> <span class="nx">B</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">MemoisedCouanterB</span> <span class="nx">obj</span><span class="o">=</span><span class="p">{</span><span class="nx">obj</span><span class="p">}</span><span class="o">&gt;&lt;</span><span class="sr">/MemoisedCouanterB</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setObj</span><span class="p">({</span><span class="na">count</span><span class="p">:</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">})}</span><span class="o">&gt;</span><span class="nx">B</span> <span class="nx">BUTTON</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">areEqual()</code> 함수를 적용해보았다. 이렇게 바꿔줄 경우, 먼저 <code class="language-plaintext highlighter-rouge">areEqual()</code> 함수에서 obj가 아니라 obj.count를 비교한다. 객체가 아니라 값을 비교하기 때문에 값이 같다면 true가 나오고, 아니라면 false가 나오게 된다. 그리고 React.memo의 두 번째 인자가 false가 되는 경우에만 다시 리렌더링을 수행하게 되기 때문에, 얕은 비교를 막고 실제로 값이 변경되었을 때에만 리렌더링이 일어나게 된다.</p>

<h2 id="usecallback으로-함수-최적화하기">useCallback으로 함수 최적화하기</h2>

<p>useMemo는 메모이제이션된 값을 반환한다. 만약 함수를 반환하고 싶을 때에는 useCallback을 사용하면 된다.</p>

<p>다이어리를 작성하는 폼인 <code class="language-plaintext highlighter-rouge">&lt;DiaryEditor&gt;</code> 컴포넌트는 App 컴포넌트에서 props로 <code class="language-plaintext highlighter-rouge">onCreate()</code> 함수를 내려받는다. 만약 다이어리가 수정되거나 삭제될 경우 App 컴포넌트에서 다이어리의 상태가 바뀌면서 <code class="language-plaintext highlighter-rouge">onCreate()</code> 함수도 재생성되고, 또 이 함수를 내려받는 <code class="language-plaintext highlighter-rouge">&lt;DiaryEditor&gt;</code> 컴포넌트도 리렌더링되게 된다. 일기 추가와만 관련이 있는데도 불구하고 불필요하게 렌더링되고 있는 것이다. 이럴 때 <code class="language-plaintext highlighter-rouge">onCreate()</code> 함수에 useCallback을 적용하면 좋다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">onCreate</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">((</span><span class="nx">author</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">newItem</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">author</span><span class="p">,</span>
    <span class="nx">content</span><span class="p">,</span>
    <span class="nx">emotion</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="nx">setData</span><span class="p">([</span><span class="nx">newItem</span><span class="p">,</span> <span class="p">...</span><span class="nx">data</span><span class="p">])</span> <span class="c1">//이렇게하면 data가 새로운 배열로 덮어씌워지기 때문에 새로운 데이터만 남게 된다.</span>
  <span class="nx">setData</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">newItem</span><span class="p">,</span> <span class="p">...</span><span class="nx">data</span><span class="p">])</span> <span class="c1">//이렇게 함수형 업데이트를 해줘야 이전 상태값을 받아와서 의도에 맞는 업데이트가 가능하다.</span>
<span class="p">},</span> <span class="p">[])</span>
</code></pre></div></div>

<p>이렇게 감싸주면 다른 함수로 인해 data가 업데이트 되어도 <code class="language-plaintext highlighter-rouge">onCreate()</code>는 달라진 부분이 없으면 다시 생성되지 않아 <code class="language-plaintext highlighter-rouge">&lt;DiaryEditor&gt;</code>가 불필요하게 리렌더링되는 것을 방지할 수 있다.</p>

<p><br /></p>

<h1 id="usereducer를-이용하여-복잡한-상태-분리하기">useReducer를 이용하여 복잡한 상태 분리하기</h1>

<p>useReducer를 이용하면 상태 관리 로직을 컴포넌트 밖으로 빼내서 컴포넌트의 복잡도를 줄일 수 있다. useReducer는 상태변화를 처리해주는 reducer와 state의 초기값으로 두 개의 인자를 받아 state와 dispatch 함수로 이루어진 배열을 반환한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">dispatch</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useReducer</span><span class="p">(</span><span class="nx">reducer</span><span class="p">,</span> <span class="p">[])</span>
</code></pre></div></div>

<p>먼저 dispatch로 상태 변화를 일으키고, reducer가 상태 변화를 처리해서 data가 변경되는 구조를 가진다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">onCreate</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">((</span><span class="nx">author</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">dispatch</span><span class="p">({</span>
    <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">CREATE</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">data</span><span class="p">:</span> <span class="p">{</span><span class="nx">author</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">,</span> <span class="na">id</span><span class="p">:</span> <span class="nx">dataId</span><span class="p">.</span><span class="nx">current</span><span class="p">},</span>
  <span class="p">})</span>

  <span class="nx">dataId</span><span class="p">.</span><span class="nx">current</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">},</span> <span class="p">[])</span>
</code></pre></div></div>

<p>dispatch는 이런 식으로 호출하면서 객체를 전달하는데, 이 객체 이름을 action 객체라고 부른다. action 객체를 reducer로 전달하면 reducer에서 상태를 변경해준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">reducer</span> <span class="o">=</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">CREATE</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">created_date</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">()</span>
      <span class="kd">const</span> <span class="nx">newItem</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">...</span><span class="nx">action</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span>
        <span class="nx">created_date</span><span class="p">,</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">[</span><span class="nx">newItem</span><span class="p">,</span> <span class="p">...</span><span class="nx">state</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="c1">//case 별로 구현</span>

    <span class="nl">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>dispatch에서는 첫번째 인자로 원래 상태를, 두 번째 인자로 dispatch가 전달해준 action 객체를 받는다.
그리고 action의 타입에 따라 state를 변경해준 뒤, 바뀐 state를 반환한다. 즉 상태가 변경된다.</p>

<p><br /></p>

<h1 id="context로-컴포넌트-트리에-전역으로-데이터-공급하기">context로 컴포넌트 트리에 전역으로 데이터 공급하기</h1>

<p>리액트는 단방향 데이터 흐름을 가지기 때문에, 데이터를 위에서 아래로 props로 전해준다. 하지만 컴포넌트가 여러 단계에 걸쳐 연결되어 있을 경우, 제일 아래에 있는 컴포넌트에서만 필요한 데이터를 전달해주려면 최상위 컴포넌트에서 그 아래로, 또 그 아래로 계속 props를 내려주게 된다. 이때 중간에 있는 컴포넌트들은 데이터를 사용하지도 않으면서 오로지 props를 전달하는 역할을 하게 된다. 이를 props 드릴링이라고 하는데, 이런 드릴링이 생길 경우 데이터를 관리하기가 매우 복잡해진다.</p>

<p>이런 문제를 해결하기 위해 context라는 개념이 생겨났다.</p>

<p><img width="1314" alt="스크린샷 2023-04-15 오후 12 55 32" src="https://user-images.githubusercontent.com/110877564/232181738-9ea2fc17-dbdf-48ec-8b1b-6ac8ec1f9337.png" />
이 그림처럼 provider라는 컴포넌트는 App 컴포넌트에서 모든 데이터를 받아서 필요한 컴포넌트에 바로 데이터를 줄 수 있다. 따라서 불필요한 데이터 드릴링이 일어나지 않게 된다.</p>

<p>이때 provider가 포함하고 있는 범위를 context, 문맥이라고 하며 이 context 안에서는 어떤 컴포넌트든 데이터를 받아와서 사용할 수 있다.</p>

<p>리액트는 <code class="language-plaintext highlighter-rouge">context API</code>를 제공하여 이런 기능을 사용할 수 있게 만들어준다.</p>

<h2 id="context-생성">context 생성</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">DiaryStateContext</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createContext</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="context-provier를-이용해서-데이터-공급하기">Context Provier를 이용해서 데이터 공급하기</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//App.js</span>
  <span class="o">&lt;</span><span class="nx">DiaryStateContext</span><span class="p">.</span><span class="nx">Provider</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">data</span> <span class="p">{</span><span class="cm">/*전역으로 공급할 값*/</span><span class="p">}}</span><span class="o">&gt;</span>
    <span class="p">{</span><span class="cm">/*context 안에 위치하는 자식 컴포넌트들*/</span><span class="p">}</span>
  <span class="o">&lt;</span><span class="sr">/DiaryStateContext.Provider</span><span class="err">&gt;
</span></code></pre></div></div>

<h2 id="하위-컴포넌트에서-데이터를-가져와서-사용하기">하위 컴포넌트에서 데이터를 가져와서 사용하기</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//DiaryList.jsx</span>
<span class="kd">const</span> <span class="nx">diaryList</span> <span class="o">=</span> <span class="nx">useContext</span><span class="p">(</span><span class="nx">DiaryStateContext</span><span class="p">)</span> <span class="c1">//data가 할당된다.</span>
</code></pre></div></div>

<h2 id="context-중첩해서-사용하기">context 중첩해서 사용하기</h2>

<p>데이터 뿐만 아니라 상태를 변경하는 dispatch 함수도 전역으로 내려주고 싶으면 어떻게 할까? 만약 아까 만들어두었던 <code class="language-plaintext highlighter-rouge">DiaryStateContext</code>를 사용하면 데이터가 변경될 때마다 함수들도 재생성되는 문제가 발생한다. 따라서 다른 문맥을 만들어 중첩해서 사용하는 것이 좋다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//App.js</span>
<span class="kd">const</span> <span class="nx">DiaryDispatchContext</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createContext</span><span class="p">()</span> <span class="c1">//새로운 context 생성</span>

<span class="c1">//전달할 함수를 하나로 만들기</span>
<span class="kd">const</span> <span class="nx">memoizedDispatches</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">onCreate</span><span class="p">,</span> <span class="nx">onRemove</span><span class="p">,</span> <span class="nx">onEdit</span><span class="p">}</span>
<span class="p">},</span> <span class="p">[])</span>

<span class="c1">//중첩해서 사용</span>
<span class="k">return</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">DiaryStateContext</span><span class="p">.</span><span class="nx">Provider</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">data</span><span class="p">}</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">DiaryDispatchContext</span><span class="p">.</span><span class="nx">Provider</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">memoizedDispatches</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="cm">/*context 안에 위치하는 자식 컴포넌트들*/</span><span class="p">}</span>
    <span class="o">&lt;</span><span class="sr">/DiaryDispatchContext.Provider</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/DiaryStateContext.Provider</span><span class="err">&gt;
</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DiaryStateContext</code>와 마찬가지로 인자로 원하는 문맥을 넣고 꺼내서 사용하면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//DiaryItem.jsx</span>
<span class="kd">const</span> <span class="p">{</span><span class="nx">onRemove</span><span class="p">,</span> <span class="nx">onEdit</span><span class="p">}</span> <span class="o">=</span> <span class="nx">useContext</span><span class="p">(</span><span class="nx">DiaryDispatchContext</span><span class="p">)</span>
</code></pre></div></div>

<p>간단한 일기장을 만들면서 CRUD 기능, 최적화, 상태 관리까지 전체적으로 알아볼 수 있었던 섹션이었다.</p>
 
      </section>

      <footer class="page__meta"></footer>

      <!-- <section class="page__share">
  
  <h4 class="page__share-title">
    Link
  </h4>
   -->
<!-- 
  <a
    href="https://github.com/sena-22"
    class="btn btn--twitter"
    onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"
    title="Link Github"
    ><i class="fab fa-fw fa-twitter" aria-hidden="true"></i
    ><span>GitHub</span></a
  > -->
<!-- </section> -->
 
  <nav class="pagination">
    
      <a href="/css/tailwind/" class="pagination--pager" title="Tailwind CSS 알아보기
">Previous</a>
    
    
      <a href="/redux/" class="pagination--pager" title="Redux
">Next</a>
    
  </nav>

    </div>

    
  </article>

   
  <div class="page__related">
    <h2 class="page__related-title">
       
    </h2>
    <div class="grid__wrapper">
       



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/mini%20project/emotion-diary-5/" rel="permalink">[Mini Project] 감성 일기장 업그레이드 5. Zustand 적용해보기
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          less than 1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">wanted challenge
</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/notes/kakao-map/" rel="permalink">[react + typescript] kakao map api 사용하기
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          less than 1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">kakao map api
</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/typescript/tsc/" rel="permalink">[typescript] 타입스크립트의 컴파일 과정
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          less than 1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">typescript
</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/redux/" rel="permalink">Redux
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          less than 1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Redux
</p>
  </article>
</div>
 
    </div>
  </div>
   
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://github.com/sena-22" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 Reyna. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>







    <script>
  'use strict';

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'sena-22/sena-22.github.io');
    script.setAttribute('issue-term', 'pathname');
    
    script.setAttribute('theme', 'github-light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





  </body>
</html>
